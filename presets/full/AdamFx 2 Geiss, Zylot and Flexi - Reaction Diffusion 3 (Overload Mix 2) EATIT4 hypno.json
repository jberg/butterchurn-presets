{"version":2,"baseVals":{"rating":1,"gammaadj":1.9,"echo_zoom":1.169,"wave_a":0.001,"warpanimspeed":30.965,"warpscale":2.572,"zoomexp":1.94773,"zoom":1.00901,"warp":0.00054,"wave_r":0,"wave_g":0,"wave_b":0,"mv_a":0},"shapes":[{"baseVals":{"textured":1,"x":0.75,"y":0.75,"rad":0.7418,"tex_zoom":0.22746,"g":1,"b":1,"r2":1,"b2":1,"border_r":0,"border_g":0,"border_a":0,"enabled":0},"init_eqs_str":"tex_saw = 0.4;","frame_eqs_str":"ang = q1*0.2;\n\ntex_capture = above(q3,2);\ntex_zoom = 0.6;","init_eqs_eel":"tex_saw = 0.4;","frame_eqs_eel":"ang = q1*0.2;\n\ntex_capture = above(q3,2);\ntex_zoom = 0.6;"},{"baseVals":{"enabled":1,"additive":1,"rad":0.0444,"tex_zoom":0.22746,"r":0,"g":0.3,"g2":0,"border_r":0,"border_g":0,"border_a":0},"init_eqs_str":"a.tex_saw=.4;","frame_eqs_str":"","init_eqs_eel":"tex_saw = 0.4;","frame_eqs_eel":""},{"baseVals":{"sides":100,"rad":0.22167,"border_a":1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"border_r = 0.5 + 0.5*sin(q1*10);","init_eqs_eel":"","frame_eqs_eel":"border_r = 0.5 + 0.5*sin(q1*10);"},{"baseVals":{"sides":100,"g":1,"b":1,"r2":1,"b2":1,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"a = above(q3,2);\na2 = above(q3,2)*0.8;\n\nxx = if(above(q3,6),xx,int(rand(100))*0.01);\nyy = if(above(q3,6),yy,int(rand(100))*0.01);\nradi = if(above(q3,5),radi,int(rand(100))*0.01);\n\nrad = radi;\n\nx = xx;\ny = yy;\n\n\nr = 0.5 + 0.5*sin(q1*1.22) + 0.1;\ng = 0.4 + 0.4*sin(q1*1.307);\nb = 0.4 + 0.4*sin(q1*1.959);\n\n\nr2 = 0.5 + 0.5*sin(q1*1.622) + 0.1;\ng2 = 0.4 + 0.4*sin(q1*1.507);\nb2 = 0.4 + 0.4*sin(q1*1.6559);","init_eqs_eel":"","frame_eqs_eel":"a = above(q3,2);\na2 = above(q3,2)*0.8;\n\nxx = if(above(q3,6),xx,int(rand(100))*0.01);\nyy = if(above(q3,6),yy,int(rand(100))*0.01);\nradi = if(above(q3,5),radi,int(rand(100))*0.01);\n\nrad = radi;\n\nx = xx;\ny = yy;\n\n\nr = 0.5 + 0.5*sin(q1*1.22) + 0.1;\ng = 0.4 + 0.4*sin(q1*1.307);\nb = 0.4 + 0.4*sin(q1*1.959);\n\n\nr2 = 0.5 + 0.5*sin(q1*1.622) + 0.1;\ng2 = 0.4 + 0.4*sin(q1*1.507);\nb2 = 0.4 + 0.4*sin(q1*1.6559);"}],"waves":[{"baseVals":{"enabled":1,"a":0.5},"init_eqs_str":"a.zs=0;a.speed=0;a.q1=0;a.zd=0;","frame_eqs_str":"","point_eqs_str":"a.zs=.00001<Math.abs(below(a.zs,1))?9:a.zs;a.zs=.00001<Math.abs(above(a.zs,1100))?1:a.zs;a.speed=.002*a.bass;a.zs+=Math.tan(.015*a.q1)*a.speed;a.zd+=2;a.x=.5+.1*Math.cos(a.q1*a.zs);a.y=.5+.1*Math.sin(a.q1*a.zs);a.r=.5+.5*Math.sin(1.2*a.q1+a.x+a.x);a.g=.5+.5*Math.sin(1.5*a.q1+a.x+a.y);a.b=.5+.5*Math.sin(1.36*a.q1+a.y+a.y);","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"//init\nzs = if(below(zs,1),9,zs);\n\nzs = if(above(zs, 1100),1, zs);\n\nspeed = bass*0.002;\n\n//sum\nzs = zs + tan(q1*0.015)*speed;\n\nzd = zd + 2;\n\n\n\n//project\nx = 0.5 + 0.1*cos(q1*zs);\ny = 0.5 + 0.1*sin(q1*zs);\n\nr = 0.5 + 0.5*sin(q1*1.2 + x + x);\ng = 0.5 + 0.5*sin(q1*1.5 + x + y);\nb = 0.5 + 0.5*sin(q1*1.36 + y + y);"},{"baseVals":{"thick":1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"thick":1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"","frame_eqs_str":"a.rot=-.001;a.zoom=1.01;","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"rot = -0.001;\n//rot = rot + 0.010*( 0.60*sin(0.381*time) + 0.40*sin(0.579*time) );\n\nzoom =1.01;// + bass*0.05 - treb*0.015;","pixel_eqs_eel":"","warp":" shader_body { \n  vec2 uv_1;\n  vec3 ret_2;\n  uv_1 = (uv + (vec2(1.0, 0.0) * texsize.zw));\n  ret_2 = texture (sampler_main, uv_1).xyz;\n  ret_2.xz = (ret_2.xz + ((\n    (ret_2.xz - mix (((texture (sampler_blur2, uv_1).xyz * scale2) + bias2), ((texture (sampler_blur1, uv_1).xyz * scale1) + bias1), uv_orig.xxx).xz)\n   * 0.3) - (0.00666 * \n    (((bass + treb) + mid) - 0.5)\n  )));\n  ret_2.xz = (ret_2.xz * 0.95);\n  ret_2.xz = (ret_2.xz + ((\n    ((texture (sampler_noise_lq, ((\n      (uv_orig * texsize.xy)\n     * \n      (texsize_noise_lq.zw * 0.4)\n    ) + rand_frame.xy)).xz - 0.5) / 256.0)\n   * 122.0) * clamp (\n    (treb_att - 1.0)\n  , 0.0, 1.0)));\n  ret_2.x = mix (ret_2.x, dot (ret_2.xxx, vec3(0.32, 0.49, 0.29)), 0.2);\n  vec2 tmpvar_3;\n  tmpvar_3 = (texsize.zw * 12.0);\n  vec3 tmpvar_4;\n  tmpvar_4 = (((texture (sampler_blur2, \n    (uv_orig + (vec2(1.0, 0.0) * tmpvar_3))\n  ).xyz * scale2) + bias2) - ((texture (sampler_blur2, \n    (uv_orig - (vec2(1.0, 0.0) * tmpvar_3))\n  ).xyz * scale2) + bias2));\n  vec3 tmpvar_5;\n  tmpvar_5 = (((texture (sampler_blur2, \n    (uv_orig + (vec2(0.0, 1.0) * tmpvar_3))\n  ).xyz * scale2) + bias2) - ((texture (sampler_blur2, \n    (uv_orig - (vec2(0.0, 1.0) * tmpvar_3))\n  ).xyz * scale2) + bias2));\n  vec2 tmpvar_6;\n  tmpvar_6.x = tmpvar_4.x;\n  tmpvar_6.y = tmpvar_5.x;\n  vec2 tmpvar_7;\n  tmpvar_7.x = tmpvar_4.y;\n  tmpvar_7.y = tmpvar_5.y;\n  vec2 tmpvar_8;\n  tmpvar_8.x = tmpvar_4.z;\n  tmpvar_8.y = tmpvar_5.z;\n  vec2 tmpvar_9;\n  tmpvar_9 = (((uv_orig + \n    (tmpvar_6 * 0.005)\n  ) + (tmpvar_7 * 0.005)) - (tmpvar_8 * 0.005));\n  ret_2.y = (texture (sampler_main, tmpvar_9).y - 0.04);\n  ret_2.y = (ret_2.y + ((\n    (ret_2.y - (((texture (sampler_blur1, tmpvar_9).xyz * scale1) + bias1).y * 1.5))\n   + 0.4) * 0.1));\n  vec4 tmpvar_10;\n  tmpvar_10.w = 1.0;\n  tmpvar_10.xyz = ret_2;\n  ret = tmpvar_10.xyz;\n }","comp":" shader_body { \n  float ang2_1;\n  vec2 uv2_2;\n  ang2_1 = ((ang * 0.1591549) + (time * 0.025));\n  ang2_1 = (fract((ang2_1 * 9.0)) / 9.0);\n  ang2_1 = (abs((ang2_1 - 0.05555556)) * 6.283185);\n  vec2 tmpvar_3;\n  tmpvar_3.x = cos(ang2_1);\n  tmpvar_3.y = sin(ang2_1);\n  uv2_2 = (0.5 + ((\n    (0.4 * (rad * sqrt(dot (texsize.xy, texsize.xy))))\n   * tmpvar_3) * texsize.zw));\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = (((texture (sampler_main, uv2_2).y * vec3(0.6, 0.2, 1.5)) + (texture (sampler_fw_main, uv2_2).x * vec3(1.0, 0.66, 0.0))) - (texture (sampler_main, uv2_2).z * vec3(-0.6, 1.0, 2.0)));\n  ret = tmpvar_4.xyz;\n }","warp_hlsl":"shader_body\n{\nuv = uv + float2(1,0)*texsize.zw;\n    // sample previous frame\n    ret.xyz = tex2D( sampler_main, uv ).xyz;\n\n      // take the difference between the crisp and blurred images,\n      // then add it back into the image.  Creates spots and stripes over time.\n      float2 b = lerp(GetBlur2(uv),GetBlur1(uv),uv_orig.x).xz;//GetBlur2(uv);\n      ret.xz += (ret.xz - b)*0.3 - (((bass+treb+mid-0.5)*.333)*.02);\n      ret.xz *= 0.95;\n\n      // add noise:\n      float2 dither_uv = uv_orig*texsize.xy*texsize_noise_lq.zw * 0.4 + rand_frame.xy;\n      ret.xz += (tex2D(sampler_noise_lq, dither_uv).xz-0.5)/256.0 * 122 * saturate(treb_att-1);\n\n      // desaturate over time, to keep the globs white\n      ret.x = lerp(ret.x, lum(ret.x), 0.2);\n\n      float2 pix = texsize.zw*12;\n      float3 dx = (GetBlur2(uv_orig + float2(1,0)*pix) - GetBlur2(uv_orig - float2(1,0)*pix));\n      float3 dy = (GetBlur2(uv_orig + float2(0,1)*pix) - GetBlur2(uv_orig - float2(0,1)*pix));\n      float2 my_uv = uv_orig + float2(dx.x,dy.x)*0.005 + float2(dx.y,dy.y)*0.005 - float2(dx.z,dy.z)*0.005;\n\n      ret.y = tex2D(sampler_main, my_uv).y - 0.04;\n      ret.y += (ret.y - GetBlur1(my_uv).y*1.5 + 0.4)*0.1;\n}","comp_hlsl":"shader_body\n{\n    float rad_lq = rad * length(texsize.xy)*0.5;\n    float ang_lq = ang;\n    float2 uv_temp1 = (uv - 0.5) * texsize.xy;\n    float rad_hq = length(uv_temp1);\n    float ang_hq = atan2(-uv_temp1.y, uv_temp1.x);\n\n    float2 uv2 = (uv - 0.5);\n    float rad2 = rad_lq*0.8;\n    float ang2 = ang_lq * M_INV_PI_2;\n\n          ang2 += time*0.025;   //rotate over time\n\n        // FIN TYPE\n        float fins = 9;\n        #if 1     // SHARP FINS\n          ang2 = frac(ang2*fins)/fins;\n              // ENABLE THIS TO MAKE THE FINS ALTERNATE: (seamless!)\n              ang2 = abs(ang2 - 0.5/fins);\n        #else     // COSINE FINS - a bit slow\n//          ang2 = cos(ang2*M_PI_2*fins) * 0.023;\n        #endif\n\n        // RADIAL KALEIDOSCOPING?\n        #if 0\n          rad2 *= g_fTexSize.z;\n            // choose one:\n            //rad2 = lerp(rad2, frac(rad2*3)/3.0, 0.5);\n            rad2 = cos(rad2*5);\n            //rad2 = sqrt(rad2)*0.5;\n            //rad2 += abs(frac(rad2*7)-0.5)/7.0 * 1.15;  // stepifier\n            //rad2 += cos(rad2*61)*0.02;\n          rad2 *= g_fTexSize.x;\n        #endif\n\n    ang2 *= M_PI_2;\n    uv2 = 0.5 + rad2*float2(cos(ang2),sin(ang2))*texsize.zw;\n\n    ret = tex2D(sampler_main,uv2).y*float3(0.6,0.2,1.5) + tex2D(sampler_fw_main,uv2).x*float3(1,0.66,0) - tex2D(sampler_main,uv2).z*float3(-0.6,1,2);\n}"}