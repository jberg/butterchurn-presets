{"version":2,"baseVals":{"rating":5,"gammaadj":1.98,"decay":0.5,"echo_zoom":1,"echo_alpha":0.5,"echo_orient":3,"wave_mode":1,"darken":1,"wave_a":0.001,"warpanimspeed":1.459,"warpscale":2.007,"zoom":0.9999,"warp":0.01,"sx":0.9999,"wave_r":0,"wave_g":0,"wave_b":0,"ob_size":0,"ob_a":0.7,"ib_size":0.26,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{"enabled":1,"sides":100,"textured":1,"rad":2.66717,"a":0.4,"a2":0.4,"border_a":0},"init_eqs_str":"a.q1=0;","frame_eqs_str":"a.r=Math.sin(a.q1);a.g=Math.sin(1.1*a.q1);a.b=Math.sin(1.4*a.q1);a.r2=Math.sin(1.25*a.q1);a.g2=Math.sin(1.45*a.q1);a.b2=Math.sin(1.12*a.q1);","init_eqs_eel":"","frame_eqs_eel":"r = sin(q1);\ng = sin(q1*1.1);\nb = sin(q1*1.4);\nr2 = sin(q1*1.25);\ng2 = sin(q1*1.45);\nb2 = sin(q1*1.12);"},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":1,"thick":1,"additive":1,"scaling":0.88026,"smoothing":1,"a":0.2},"init_eqs_str":"a.xx=0;a.s=0;a.xs=0;a.ztor=0;a.xtor=0;a.ytor=0;a.ss=0;a.q1=0;a.q5=0;a.xd=0;a.zd=0;a.v=0;a.yx=0;a.angle2=0;a.zs=0;a.angle=0;a.ys=0;a.level=0;a.xn=0;a.yd=0;a.angle3=0;a.yn=0;a.peek1=0;a.u=0;a.zx=0;","frame_eqs_str":"","point_eqs_str":"a.u=3.14159*Math.abs(Math.cos(.1*a.q1));a.v=6.28318*Math.abs(Math.cos(.015*a.q1));a.s=314*a.sample;a.ss=6280*a.sample;a.xs=.5*Math.sin(a.s)*Math.cos(a.ss)*equal(a.q5,0)+(.6+.1*Math.cos(a.s))*Math.cos(a.ss)*equal(a.q5,1)+.5*Math.sin(a.s)*Math.cos(a.ss)*equal(a.q5,2);a.ys=.5*Math.sin(a.s)*Math.sin(a.ss)*equal(a.q5,0)+(.6+.1*Math.cos(a.s))*Math.sin(a.ss)*equal(a.q5,1)+.5*Math.sin(a.s)*Math.sin(a.ss)*equal(a.q5,2);a.zs=.5*Math.cos(a.s)*equal(a.q5,0)+.1*Math.sin(a.s)*equal(a.q5,\n1)+.5*Math.sin(a.s)*equal(a.q5,2);a.xtor=(.6+.1*Math.cos(a.s))*Math.cos(a.ss);a.ytor=(.6+.1*Math.cos(a.s))*Math.sin(a.ss);a.ztor=.1*Math.sin(a.s);a.angle=.3*a.q1;a.yx=a.ys*Math.cos(a.angle)-a.zs*Math.sin(a.angle);a.zx=a.ys*Math.sin(a.angle)+a.zs*Math.cos(a.angle);a.xx=a.xs;a.angle2=.5*a.q1;a.xd=a.xx*Math.cos(a.angle2)-a.zx*Math.sin(a.angle2);a.zd=a.xx*Math.sin(a.angle2)+a.zx*Math.cos(a.angle2);a.yd=a.yx;a.angle3=.41*a.q1;a.xn=a.xd*Math.cos(a.angle3)-a.yd*Math.sin(a.angle3);a.yn=a.xd*Math.sin(a.angle3)+\na.yd*Math.cos(a.angle3);a.zd+=2;a.peek1=10*(a.value1+a.value2);a.level=.00001<Math.abs(above(a.peek1,a.level))?a.peek1:a.level-.00025;a.level=.00001<Math.abs(below(a.level,0))?0:a.level;a.zd=a.zd+2+a.level;a.x=a.xn*a.zd*.05+.5;a.y=a.yn*a.zd*.06+.5;a.r=.5+.5*Math.sin(1.2*a.q1+a.x+a.x);a.g=.5+.5*Math.sin(1.5*a.q1+a.x+a.y);a.b=.5+.5*Math.sin(1.36*a.q1+a.y+a.y);","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"u = abs(cos(q1*0.1))*3.14159;\nv = abs(cos(q1*0.015))*3.14159*2;\ns = sample*3.14*100;\nss = sample*6.28*1000;\n\n//draw\nxs = 0.5*sin(s)*cos(ss)*equal(q5,0) +\n(0.6 + 0.1*cos(s))*cos(ss)*equal(q5,1) +\n0.5*sin(s)*cos(ss)*equal(q5,2);\nys = 0.5*sin(s)*sin(ss)*equal(q5,0) +\n(0.6 + 0.1*cos(s))*sin(ss)*equal(q5,1) +\n0.5*sin(s)*sin(ss)*equal(q5,2);\nzs = 0.5*cos(s)*equal(q5,0) +\n0.1*sin(s)*equal(q5,1) +\n0.5*sin(s)*equal(q5,2);\n\n\n\nxtor = (0.6 + 0.1*cos(s))*cos(ss);\nytor = (0.6 + 0.1*cos(s))*sin(ss);\nztor = 0.1*sin(s);\n\n\n//rotate x axis\nangle = q1*0.3;\nyx = ys*cos(angle) - zs*sin(angle);\nzx = ys*sin(angle) + zs*cos(angle);\nxx = xs;\n\n//rotate y axis\nangle2 = q1*0.5;\nxd = xx*cos(angle2) - zx*sin(angle2);\nzd = xx*sin(angle2) + zx*cos(angle2);\nyd = yx;\n\n//rotaye z axis\nangle3 = q1*0.41;\nxn = xd*cos(angle3) - yd*sin(angle3);\nyn = xd*sin(angle3) + yd*cos(angle3);\n\nzd = zd + 2;\n\n//do that falloff effect\npeek1 = (value1 + value2)*10;\n\n//if sample louder set that to level else decrement level\nlevel = if(above(peek1,level),peek1,level - 0.00025);\nlevel = if(below(level,0),0,level);\n\n//add to z\nzd = zd + 2  + level;\n\n\nx = xn*zd*0.05 + 0.5;\ny = yn*zd*0.05*1.2 + 0.5;\n\n\nr = 0.5 + 0.5*sin(q1*1.2 + x + x);\ng = 0.5 + 0.5*sin(q1*1.5 + x + y);\nb = 0.5 + 0.5*sin(q1*1.36 + y + y);"},{"baseVals":{"enabled":1,"thick":1,"additive":1,"scaling":0.88026,"smoothing":1,"a":0.2},"init_eqs_str":"a.xx=0;a.s=0;a.xs=0;a.ztor=0;a.xtor=0;a.ytor=0;a.ss=0;a.q1=0;a.q5=0;a.xd=0;a.zd=0;a.v=0;a.yx=0;a.angle2=0;a.zs=0;a.angle=0;a.ys=0;a.level=0;a.xn=0;a.yd=0;a.angle3=0;a.yn=0;a.peek1=0;a.u=0;a.zx=0;","frame_eqs_str":"","point_eqs_str":"a.u=3.14159*Math.abs(Math.cos(.1*a.q1));a.v=6.28318*Math.abs(Math.cos(.015*a.q1));a.s=314*a.sample;a.ss=6280*a.sample;a.xs=.5*Math.sin(a.s)*Math.cos(a.ss)*equal(a.q5,2)+(.6+.1*Math.cos(a.s))*Math.cos(a.ss)*equal(a.q5,0)+.5*Math.sin(a.s)*Math.cos(a.ss)*equal(a.q5,1);a.ys=.5*Math.sin(a.s)*Math.sin(a.ss)*equal(a.q5,2)+(.6+.1*Math.cos(a.s))*Math.sin(a.ss)*equal(a.q5,0)+.5*Math.sin(a.s)*Math.sin(a.ss)*equal(a.q5,1);a.zs=.5*Math.cos(a.s)*equal(a.q5,2)+.1*Math.sin(a.s)*equal(a.q5,\n0)+.5*Math.sin(a.s)*equal(a.q5,1);a.xtor=(.6+.1*Math.cos(a.s))*Math.cos(a.ss);a.ytor=(.6+.1*Math.cos(a.s))*Math.sin(a.ss);a.ztor=.1*Math.sin(a.s);a.angle=.3*a.q1;a.yx=a.ys*Math.cos(a.angle)-a.zs*Math.sin(a.angle);a.zx=a.ys*Math.sin(a.angle)+a.zs*Math.cos(a.angle);a.xx=a.xs;a.angle2=.5*a.q1;a.xd=a.xx*Math.cos(a.angle2)-a.zx*Math.sin(a.angle2);a.zd=a.xx*Math.sin(a.angle2)+a.zx*Math.cos(a.angle2);a.yd=a.yx;a.angle3=.41*a.q1;a.xn=a.xd*Math.cos(a.angle3)-a.yd*Math.sin(a.angle3);a.yn=a.xd*Math.sin(a.angle3)+\na.yd*Math.cos(a.angle3);a.zd+=2;a.peek1=10*(a.value1+a.value2);a.level=.00001<Math.abs(above(a.peek1,a.level))?a.peek1:a.level-.00025;a.level=.00001<Math.abs(below(a.level,0))?0:a.level;a.zd=a.zd+2+a.level;a.x=a.xn*a.zd*.05+.5;a.y=a.yn*a.zd*.06+.5;a.r=.5+.5*Math.sin(1.2*a.q1+a.x+a.x);a.g=.5+.5*Math.sin(1.5*a.q1+a.x+a.y);a.b=.5+.5*Math.sin(1.16*a.q1+a.y+a.y);","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"u = abs(cos(q1*0.1))*3.14159;\nv = abs(cos(q1*0.015))*3.14159*2;\ns = sample*3.14*100;\nss = sample*6.28*1000;\n\n//draw\nxs = 0.5*sin(s)*cos(ss)*equal(q5,2) +\n(0.6 + 0.1*cos(s))*cos(ss)*equal(q5,0) +\n0.5*sin(s)*cos(ss)*equal(q5,1);\nys = 0.5*sin(s)*sin(ss)*equal(q5,2) +\n(0.6 + 0.1*cos(s))*sin(ss)*equal(q5,0) +\n0.5*sin(s)*sin(ss)*equal(q5,1);\nzs = 0.5*cos(s)*equal(q5,2) +\n0.1*sin(s)*equal(q5,0) +\n0.5*sin(s)*equal(q5,1);\n\n\nxtor = (0.6 + 0.1*cos(s))*cos(ss);\nytor = (0.6 + 0.1*cos(s))*sin(ss);\nztor = 0.1*sin(s);\n\n\n//rotate x axis\nangle = q1*0.3;\nyx = ys*cos(angle) - zs*sin(angle);\nzx = ys*sin(angle) + zs*cos(angle);\nxx = xs;\n\n//rotate y axis\nangle2 = q1*0.5;\nxd = xx*cos(angle2) - zx*sin(angle2);\nzd = xx*sin(angle2) + zx*cos(angle2);\nyd = yx;\n\n//rotaye z axis\nangle3 = q1*0.41;\nxn = xd*cos(angle3) - yd*sin(angle3);\nyn = xd*sin(angle3) + yd*cos(angle3);\n\nzd = zd + 2;\n\n//do that falloff effect\npeek1 = (value1 + value2)*10;\n\n//if sample louder set that to level else decrement level\nlevel = if(above(peek1,level),peek1,level - 0.00025);\nlevel = if(below(level,0),0,level);\n\n//add to z\nzd = zd + 2  + level;\n\n\nx = xn*zd*0.05 + 0.5;\ny = yn*zd*0.05*1.2 + 0.5;\n\n\nr = 0.5 + 0.5*sin(q1*1.2 + x + x);\ng = 0.5 + 0.5*sin(q1*1.5 + x + y);\nb = 0.5 + 0.5*sin(q1*1.16 + y + y);"},{"baseVals":{"spectrum":1,"additive":1,"a":0.5,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"u = abs(cos(q1*0.1))*3.14159;\nv = abs(cos(q1*0.015))*3.14159*2;\ns = sample*3.14;\nss = sample*6.28*100;\n\n//draw\nxs = 0.5*sin(s)*cos(ss);\nys = 0.5*sin(s)*sin(ss);\nzs = 0.5*sin(s);\n\n\n//plot x,y,z to point on circle\n//smp=sample*6.283;\n//xp=sin(smp )*0.30;\n//yp=cos(smp )*0.30;\n//zp=0;\n\n\n//alter shape;\n///angy=sin(sample*6.28*4 +t1 )*6.28;\n//xq=xp*cos(angy) - zp*sin(angy);\n//zq=xp*sin(angy) + zp*cos(angy);\n//xp=xq;\n//zp=zq;\n\n\n\n//rotate on y axis;\n//angy=t1*0.1;\n//xq=xp*cos(angy) - zp*sin(angy);\n//zq=xp*sin(angy) + zp*cos(angy);\n//xp=xq;\n//zp=zq;\n\n//rotate on x axis\n//axs1 = sin(t1*0.15) + 1.6;\n//yq= yp*cos(axs1) - zp*sin(axs1);\n//zq= yp*sin(axs1) + zp*cos(axs1);\n//yp=yq;\n//zp=zq;\n\n//rotate on y axis again\n//axs2 = sin(t1*0.1)*3.3;\n//xq=xp*cos(axs2) - zp*sin(axs2);\n//zq=xp*sin(axs2) + zp*cos(axs2);\n//xp=xq;\n//zp=zq;\n\n\n\n\n//rotate x axis\nangle = sin(q1*0.15 + 3.14);\nyx = ys*cos(angle) - zs*sin(angle);\nzx = ys*sin(angle) + zs*cos(angle);\nxx = xs;\n\n//rotate y axis\nangle2 = sin(q1*0.2 + 3.14);\nxd = xx*cos(angle2) - zx*sin(angle2);\nzd = xx*sin(angle2) + zx*cos(angle2);\nyd = yx;\n\nzd = zd + 2;\n\nx = xd*zd*0.3*1.2 + 0.5;\ny = yd*zd*0.3*1.2 + 0.5;\n\n\nr = 0.5 + 0.5*sin(q1*1.2 + x + x);\ng = 0.5 + 0.5*sin(q1*1.5 + x + y);\nb = 0.5 + 0.5*sin(q1*1.36 + y + y);","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"u = abs(cos(q1*0.1))*3.14159;\nv = abs(cos(q1*0.015))*3.14159*2;\ns = sample*3.14;\nss = sample*6.28*100;\n\n//draw\nxs = 0.5*sin(s)*cos(ss);\nys = 0.5*sin(s)*sin(ss);\nzs = 0.5*sin(s);\n\n\n//plot x,y,z to point on circle\n//smp=sample*6.283;\n//xp=sin(smp )*0.30;\n//yp=cos(smp )*0.30;\n//zp=0;\n\n\n//alter shape;\n///angy=sin(sample*6.28*4 +t1 )*6.28;\n//xq=xp*cos(angy) - zp*sin(angy);\n//zq=xp*sin(angy) + zp*cos(angy);\n//xp=xq;\n//zp=zq;\n\n\n\n//rotate on y axis;\n//angy=t1*0.1;\n//xq=xp*cos(angy) - zp*sin(angy);\n//zq=xp*sin(angy) + zp*cos(angy);\n//xp=xq;\n//zp=zq;\n\n//rotate on x axis\n//axs1 = sin(t1*0.15) + 1.6;\n//yq= yp*cos(axs1) - zp*sin(axs1);\n//zq= yp*sin(axs1) + zp*cos(axs1);\n//yp=yq;\n//zp=zq;\n\n//rotate on y axis again\n//axs2 = sin(t1*0.1)*3.3;\n//xq=xp*cos(axs2) - zp*sin(axs2);\n//zq=xp*sin(axs2) + zp*cos(axs2);\n//xp=xq;\n//zp=zq;\n\n\n\n\n//rotate x axis\nangle = sin(q1*0.15 + 3.14);\nyx = ys*cos(angle) - zs*sin(angle);\nzx = ys*sin(angle) + zs*cos(angle);\nxx = xs;\n\n//rotate y axis\nangle2 = sin(q1*0.2 + 3.14);\nxd = xx*cos(angle2) - zx*sin(angle2);\nzd = xx*sin(angle2) + zx*cos(angle2);\nyd = yx;\n\nzd = zd + 2;\n\nx = xd*zd*0.3*1.2 + 0.5;\ny = yd*zd*0.3*1.2 + 0.5;\n\n\nr = 0.5 + 0.5*sin(q1*1.2 + x + x);\ng = 0.5 + 0.5*sin(q1*1.5 + x + y);\nb = 0.5 + 0.5*sin(q1*1.36 + y + y);"},{"baseVals":{"a":0.5,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"u = abs(cos(q1*0.1))*3.14159;\nv = abs(cos(q1*0.015))*3.14159*2;\ns = sample*20;\n\n//draw\nxs = 0.5*sin(s)*cos(s*v);\nys = 0.5*sin(s)*sin(s*v);\nzs = 0.5*sin(u);\n\n\n//plot x,y,z to point on circle\n//smp=sample*6.283;\n//xp=sin(smp )*0.30;\n//yp=cos(smp )*0.30;\n//zp=0;\n\n\n//alter shape;\n///angy=sin(sample*6.28*4 +t1 )*6.28;\n//xq=xp*cos(angy) - zp*sin(angy);\n//zq=xp*sin(angy) + zp*cos(angy);\n//xp=xq;\n//zp=zq;\n\n\n\n//rotate on y axis;\n//angy=t1*0.1;\n//xq=xp*cos(angy) - zp*sin(angy);\n//zq=xp*sin(angy) + zp*cos(angy);\n//xp=xq;\n//zp=zq;\n\n//rotate on x axis\n//axs1 = sin(t1*0.15) + 1.6;\n//yq= yp*cos(axs1) - zp*sin(axs1);\n//zq= yp*sin(axs1) + zp*cos(axs1);\n//yp=yq;\n//zp=zq;\n\n//rotate on y axis again\n//axs2 = sin(t1*0.1)*3.3;\n//xq=xp*cos(axs2) - zp*sin(axs2);\n//zq=xp*sin(axs2) + zp*cos(axs2);\n//xp=xq;\n//zp=zq;\n\n\n\n\n//rotate x axis\nangle = sin(q1*0.15 - 1.57);\nyx = ys*cos(angle) - zs*sin(angle);\nzx = ys*sin(angle) + zs*cos(angle);\nxx = xs;\n\n//rotate y axis\n//angle2 = sin(q1*0.2 - 1.57);\nxd = xx*cos(angle2) - zx*sin(angle2);\nzd = xx*sin(angle2) + zx*cos(angle2);\nyd = yx;\n\n\nx = xd*zd + 0.5;\ny = yd*zd + 0.5;\n\n\nr = 0.5 + 0.5*sin(q1*1.2 + x + x);\ng = 0.5 + 0.5*sin(q1*1.5 + x + y);\nb = 0.5 + 0.5*sin(q1*1.36 + y + y);","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"u = abs(cos(q1*0.1))*3.14159;\nv = abs(cos(q1*0.015))*3.14159*2;\ns = sample*20;\n\n//draw\nxs = 0.5*sin(s)*cos(s*v);\nys = 0.5*sin(s)*sin(s*v);\nzs = 0.5*sin(u);\n\n\n//plot x,y,z to point on circle\n//smp=sample*6.283;\n//xp=sin(smp )*0.30;\n//yp=cos(smp )*0.30;\n//zp=0;\n\n\n//alter shape;\n///angy=sin(sample*6.28*4 +t1 )*6.28;\n//xq=xp*cos(angy) - zp*sin(angy);\n//zq=xp*sin(angy) + zp*cos(angy);\n//xp=xq;\n//zp=zq;\n\n\n\n//rotate on y axis;\n//angy=t1*0.1;\n//xq=xp*cos(angy) - zp*sin(angy);\n//zq=xp*sin(angy) + zp*cos(angy);\n//xp=xq;\n//zp=zq;\n\n//rotate on x axis\n//axs1 = sin(t1*0.15) + 1.6;\n//yq= yp*cos(axs1) - zp*sin(axs1);\n//zq= yp*sin(axs1) + zp*cos(axs1);\n//yp=yq;\n//zp=zq;\n\n//rotate on y axis again\n//axs2 = sin(t1*0.1)*3.3;\n//xq=xp*cos(axs2) - zp*sin(axs2);\n//zq=xp*sin(axs2) + zp*cos(axs2);\n//xp=xq;\n//zp=zq;\n\n\n\n\n//rotate x axis\nangle = sin(q1*0.15 - 1.57);\nyx = ys*cos(angle) - zs*sin(angle);\nzx = ys*sin(angle) + zs*cos(angle);\nxx = xs;\n\n//rotate y axis\n//angle2 = sin(q1*0.2 - 1.57);\nxd = xx*cos(angle2) - zx*sin(angle2);\nzd = xx*sin(angle2) + zx*cos(angle2);\nyd = yx;\n\n\nx = xd*zd + 0.5;\ny = yd*zd + 0.5;\n\n\nr = 0.5 + 0.5*sin(q1*1.2 + x + x);\ng = 0.5 + 0.5*sin(q1*1.5 + x + y);\nb = 0.5 + 0.5*sin(q1*1.36 + y + y);"}],"init_eqs_str":"a.index2=0;a.ddir=0;a.index=0;a.q12=0;a.q18=0;a.q22=0;a.q21=0;a.height=0;a.q13=0;a.q15=0;a.q29=0;a.q6=0;a.tele=0;a.q5=0;a.dec_f=0;a.q9=0;a.dec_s=0;a.vdir=0;a.is_beat=0;a.q31=0;a.q24=0;a.ran2=0;a.q11=0;a.hpeak=0;a.ddir_=0;a.q10=0;a.ran3=0;a.dec_m=0;a.q4=0;a.dir=0;a.q16=0;a.vdir1=0;a.p2=0;a.avg=0;a.rota=0;a.trig=0;a.beat=0;a.q17=0;a.p1=0;a.peak=0;a.q27=0;a.q14=0;a.sidestep=0;a.speed=0;a.q3=0;a.t0=0;a.vol_=0;a.ran1=0;a.q32=0;a.q7=0;a.q30=0;a.q20=0;a.q8=0;a.t0a=a.time;a.t0=a.time+\n.5;a.p1=0;a.p2=0;a.height=1.5;a.speed=.2;a.p1=Math.floor(rand(100));a.p2=Math.floor(rand(100));a.sidestep=div(Math.floor(rand(10))-5,20);","frame_eqs_str":"a.dec_m=pow(.85,div(30,a.fps));a.dec_s=pow(.96,div(30,a.fps));a.dec_f=pow(.7,div(30,a.fps));a.beat=a.bass+a.mid+a.treb;a.avg=a.avg*a.dec_s+a.beat*(1-a.dec_s);a.is_beat=above(a.beat,.2+a.avg+a.peak)*above(a.time,a.t0+.2);a.t0=a.is_beat*a.time+(1-a.is_beat)*a.t0;a.peak=a.is_beat*a.beat+(1-a.is_beat)*a.peak*a.dec_m;a.index=mod(a.index+a.is_beat,16);a.index2=mod(a.index2+a.is_beat*bnot(a.index),8);a.hpeak=a.hpeak*a.dec_f+above(a.peak,6)*a.is_beat;a.q20=a.vol_;a.q22=Math.max(0,a.peak-\n0)+.01;a.q24=a.is_beat;a.q27=a.index+1;a.tele=18*(Math.sin(div(a.time,14)+div(a.p1-a.p2,73))-.75);a.q29=Math.max(Math.min(a.tele,1),0);a.ob_size=div(a.q29-Math.max(Math.min(a.tele-1,1),0),2);a.q29=3*a.q29+1;a.trig=a.is_beat*below(Math.floor(rand(100)),a.avg);a.ran1+=a.trig*(div(Math.floor(rand(100)),50)-1)*3;a.trig=a.is_beat*below(Math.floor(rand(100)),3*a.avg);a.ran2=a.ran2*bnot(a.trig)+a.trig*(div(Math.floor(rand(100)),50)-1.1);a.trig=a.is_beat*below(Math.floor(rand(100)),5*a.avg);a.ran3=a.ran3*\nbnot(a.trig)+a.trig*(div(a.avg,32)+.05);a.speed+=div(1,a.fps)*Math.max(Math.min(a.ran3+div(a.q29-1,6)-a.speed,.05),-.05);a.rota=0;a.ddir=a.ddir*a.dec_s+(1-a.dec_s)*(2*a.ran1-a.dir);a.ddir_=a.ddir_*a.dec_s+a.ddir*(1-a.dec_s);a.dir+=div(a.ddir_,a.fps)*Math.abs(a.speed);a.q9=a.dir;a.vdir1=a.vdir1*a.dec_s+8*div((1-a.dec_s)*a.ran2,a.fps);a.vdir=a.vdir*a.dec_s+(1-a.dec_s)*a.vdir1;a.vdir=.00001<Math.abs(below(a.vdir,0))?a.vdir*(.00001<Math.abs(below(a.height,3))?1-div(pow(a.height-3,2),4):1):a.vdir;a.vdir=\n.00001<Math.abs(above(a.vdir,0))?a.vdir*(.00001<Math.abs(above(a.height,4))?1-div(pow(a.height-4,2),4):1):a.vdir;a.height+=div(a.speed,a.fps)*a.vdir*16;a.height=Math.min(Math.max(a.height,1),6);a.q7=a.vdir;a.q8=.00001<Math.abs(above(a.vdir,0))?a.height:a.height-4*a.vdir;a.q3=Math.cos(a.dir);a.q4=Math.sin(a.dir);a.p1+=div(a.q3,a.fps)*a.speed*Math.cos(a.vdir);a.p2+=div(a.q4,a.fps)*a.speed*Math.cos(a.vdir);a.q5=-a.p2+a.time*a.sidestep;a.q6=a.p1;a.q10=.5*Math.sin(div(a.time,77)+div(a.p1+a.p2,47));a.q11=\n.8+div(Math.cos(div(a.p1,11)),3);a.q12=.5+.3*Math.sin(div(a.time,22)+a.p1);a.q13=.1+.3*Math.sin(div(a.p1,3));a.q14=div(1+Math.cos(div(a.p2,5)),3);a.q30=.3*(Math.cos(div(a.time,75)+div(a.p2,123))+1);a.q31=.2+.1*Math.sin(div(a.time,94));a.q32=-.2-div(Math.sin(div(a.time,22)),4);a.q15=Math.abs(Math.sin(div(a.time,45)+div(a.p1,87)))-.75;a.q16=div(.2,a.height);a.q17=Math.tan(div(a.dir,2));a.q18=a.q16-a.q15;a.q21=div(Math.min(a.hpeak,1)*Math.floor(rand(10)),10)*below(a.q15,-.5)*above(a.q10,.3);a.monitor=\na.q13;a.rot=div(-a.ddir_*a.speed,2)+a.rota;a.dx=.5;a.dy=.25+a.q7;","pixel_eqs_str":"","init_eqs_eel":"t0a = time; t0 = time+.5;\n//sdev = .01;\n//spb_ = .5; spb = .51;\np1 = 0; p2 = 0;\nheight = 1.5;\nspeed = .2;\np1 = int(rand(100)); p2 = int(rand(100)); //starting pos\nsidestep = (int(rand(10))-5)/20;","frame_eqs_eel":"dec_m = pow (0.85, 30/fps); dec_s = pow (0.96, 30/fps); dec_f = pow (0.7, 30/fps);\n\nbeat = bass+mid+treb; \navg = avg*dec_s + beat*(1-dec_s);\nis_beat = above(beat, .2+avg+peak) * above (time, t0+.2);\nt0 = is_beat*time + (1-is_beat)*t0;\npeak = is_beat * beat + (1-is_beat)*peak*dec_m;\nindex = (index + is_beat) %16;\nindex2 = (index2 + is_beat*bnot(index))%8;\nhpeak = hpeak*dec_f + above(peak,6)*is_beat;\n\nq20 = vol_;\nq22 = max(0,peak-.0)+.01;\nq24 = is_beat;\nq27 = index +1;\n\n//*********** Tele****************\ntele = 18*(sin(time/14+(p1-p2)/73)-.75);\nq29 = max(min(tele,1),0);\nob_size= (q29 - max(min(tele-1,1),0))/2 ;\nq29 = q29*3+1;\n\ntrig = is_beat*below(int(rand(100)),avg);\nran1 = ran1 + trig*(int(rand(100))/50-1)*3; //dir\n\ntrig = is_beat*below(int(rand(100)),3*avg);\nran2 = ran2*bnot(trig) + trig*(int(rand(100))/50-1.1); //vdir\n\ntrig = is_beat*below(int(rand(100)),5*avg);\nran3 = ran3*bnot(trig) + trig*(avg/32+.05); //speed\n\nspeed = speed + 1/fps*(max(min(ran3+(q29-1)/6-speed,.05),-.05));\n//speed = -.0;\nrota =  0;\n\nddir = ddir *dec_s + (1-dec_s)*(ran1*2-dir);\n//ddir = 61/fps; vdir = 0;\nddir_ = ddir_ *dec_s + ddir *(1-dec_s);\ndir = dir + ddir_/fps*abs(speed) ;\n//dir = 0;\n//dir = dir + sin(time/2)/fps*above(sin(time/2),0);\nq9 = dir;\n\nvdir1 = vdir1*dec_s + (1-dec_s)*(ran2)/fps*8;\nvdir = vdir*dec_s + (1-dec_s)*vdir1;\nvdir =  if (below(vdir,0), vdir*if(below(height,3),1-pow(height-3,2)/4,1),vdir);\nvdir =  if (above(vdir,0), vdir*if(above(height,4),1-pow(height-4,2)/4,1),vdir);\n\nheight = height + speed/fps * vdir*16;\nheight = min(max(height,1),6);\n\nq7 = vdir; //Blick vertikal; verschiebt nur uv1.y\nq8 = if (above(vdir,0),height,height-4*vdir); //Flughoehe; \n\n\n//***** Tilt\n//q1 = cos(ddir*20*speed);\n//q2 = sin(-ddir*20*speed);\n//q1 = 1; q2 = 0;\n//***** moving direction\n\nq3 = cos(dir);\nq4 = sin(dir);\n\n//***** x-y-Position\np1 = p1 + q3/fps*speed*cos(vdir);\np2 = p2 + q4/fps*speed*cos(vdir);\n\nq5 = -p2+time*sidestep;\nq6 = p1;\n\n//*******landscape\nq10 = .5*sin(time/77+(p1+p2)/47); // cloud density, -1 bis .5\n//q10 =-.4;\nq11 = .8 + cos(p1/11)/3; //rock smooth/-brightness, 0.5 - 3; //use for daylight ?#\nq12 = 0.5 + .3 * sin(time/22+p1); //hormask;\nq13 = .1+.3*sin(p1/3); // glow; -.4 - max ca 0.4, nicht ersetzen durch lavmod2\nq14 =  (1+cos(p2/5))/3;  //lava structure harshness, 0 bis 1\nq30 = .3*(cos(time/75+p2/123)+1); //horizon brightness (moon effect)\nq31 = .2 + .1 * sin(time/94); //cloud size\nq32 = -.2-sin(time/22)/4; //Planet Y\n//****** daytime\nq15 = abs(sin(time/45+p1/87))-.75; //daytime\n\n// q10 = -.4;\n\n//******sunpos xy\nq16 =  0.2/height; //sky_gnd\n\nq17 = tan(dir/2);\nq18 = q16-q15;\n//*************** flash ****************\nq21 = min(hpeak,1) * int(rand(10))/10 * below(q15,-.5) * above(q10,.3);\n\n//side = below(speed,.3)*below(q29,2)*below(ddir_,.1)*(index2%3-1);\nmonitor = q13; \nrot = -ddir_*speed/2 + rota;\ndx = .5; dy = .25+q7 ;","pixel_eqs_eel":"","warp":"float lav_gnd;\nfloat xlat_mutablecloud;\nfloat xlat_mutablelava;\nfloat xlat_mutablelavmask;\nfloat xlat_mutablelavmod;\nfloat xlat_mutablelprof;\nfloat xlat_mutablelprof2;\nfloat xlat_mutablenoise;\nvec3 xlat_mutableret1;\nvec3 xlat_mutablersl;\nvec3 xlat_mutablersl2;\nfloat xlat_mutablesky_gnd;\nfloat xlat_mutablestone;\nvec2 xlat_mutableuv2;\n shader_body { \n  vec2 tmpvar_1;\n  tmpvar_1.x = q5;\n  tmpvar_1.y = q6;\n  float fl_2;\n  xlat_mutableuv2 = ((uv * aspect.xy) * tele);\n  vec2 uvi_3;\n  uvi_3 = (tele * vec2(0.0, -0.2));\n  vec2 rs_4;\n  float z_5;\n  z_5 = ((2.0 / uvi_3.y) * (q8 - (4.0 * \n    -(q8)\n  )));\n  float tmpvar_6;\n  float tmpvar_7;\n  tmpvar_7 = (32.0 * hordist);\n  tmpvar_6 = clamp (z_5, -0.1, tmpvar_7);\n  z_5 = tmpvar_6;\n  rs_4.x = ((uvi_3.x * 2.0) * tmpvar_6);\n  rs_4.y = tmpvar_6;\n  mat2 tmpvar_8;\n  tmpvar_8[uint(0)].x = q3;\n  float tmpvar_9;\n  tmpvar_9 = -(q4);\n  tmpvar_8[uint(0)].y = tmpvar_9;\n  tmpvar_8[1u].x = q4;\n  tmpvar_8[1u].y = q3;\n  rs_4 = (rs_4 * tmpvar_8);\n  vec3 tmpvar_10;\n  tmpvar_10.xy = ((rs_4 / 64.0) + tmpvar_1);\n  tmpvar_10.z = tmpvar_6;\n  lav_gnd = (((texture (sampler_noise_hq, \n    (tmpvar_10 / 4.0)\n  .xy) * 0.2) / q8) - 0.15).x;\n  vec2 tmpvar_11;\n  tmpvar_11 = (tele * uv);\n  vec2 rs_12;\n  float z_13;\n  z_13 = ((2.0 / tmpvar_11.y) * (q8 - (4.0 * lav_gnd)));\n  float tmpvar_14;\n  tmpvar_14 = clamp (z_13, -0.1, tmpvar_7);\n  z_13 = tmpvar_14;\n  rs_12.x = ((tmpvar_11.x * 2.0) * tmpvar_14);\n  rs_12.y = tmpvar_14;\n  mat2 tmpvar_15;\n  tmpvar_15[uint(0)].x = q3;\n  tmpvar_15[uint(0)].y = tmpvar_9;\n  tmpvar_15[1u].x = q4;\n  tmpvar_15[1u].y = q3;\n  rs_12 = (rs_12 * tmpvar_15);\n  vec3 tmpvar_16;\n  tmpvar_16.xy = ((rs_12 / 64.0) + tmpvar_1);\n  tmpvar_16.z = tmpvar_14;\n  xlat_mutablelprof = (texture (sampler_noise_hq, (tmpvar_16.xy / 4.0)) - 0.75).x;\n  xlat_mutablelprof = (xlat_mutablelprof + (texture (sampler_noise_hq, (tmpvar_16.xy / 2.0)) / 2.0).x);\n  lav_gnd = (lav_gnd - ((xlat_mutablelprof / 3.0) * 0.2));\n  vec2 rs_17;\n  float z_18;\n  z_18 = ((2.0 / tmpvar_11.y) * (q8 - (4.0 * lav_gnd)));\n  float tmpvar_19;\n  tmpvar_19 = clamp (z_18, -0.1, tmpvar_7);\n  z_18 = tmpvar_19;\n  rs_17.x = ((tmpvar_11.x * 2.0) * tmpvar_19);\n  rs_17.y = tmpvar_19;\n  mat2 tmpvar_20;\n  tmpvar_20[uint(0)].x = q3;\n  tmpvar_20[uint(0)].y = tmpvar_9;\n  tmpvar_20[1u].x = q4;\n  tmpvar_20[1u].y = q3;\n  rs_17 = (rs_17 * tmpvar_20);\n  vec3 tmpvar_21;\n  tmpvar_21.xy = ((rs_17 / 64.0) + tmpvar_1);\n  tmpvar_21.z = tmpvar_19;\n  xlat_mutablelprof = (texture (sampler_noise_hq, (tmpvar_21.xy / 4.0)) - 0.75).x;\n  xlat_mutablelprof = (xlat_mutablelprof + (texture (sampler_noise_hq, (tmpvar_21.xy / 2.0)) / 2.0).x);\n  lav_gnd = (lav_gnd - ((xlat_mutablelprof / 3.0) * 0.2));\n  vec2 rs_22;\n  float z_23;\n  z_23 = ((2.0 / tmpvar_11.y) * (q8 - (4.0 * lav_gnd)));\n  float tmpvar_24;\n  tmpvar_24 = clamp (z_23, -0.1, tmpvar_7);\n  z_23 = tmpvar_24;\n  rs_22.x = ((tmpvar_11.x * 2.0) * tmpvar_24);\n  rs_22.y = tmpvar_24;\n  mat2 tmpvar_25;\n  tmpvar_25[uint(0)].x = q3;\n  tmpvar_25[uint(0)].y = tmpvar_9;\n  tmpvar_25[1u].x = q4;\n  tmpvar_25[1u].y = q3;\n  rs_22 = (rs_22 * tmpvar_25);\n  vec3 tmpvar_26;\n  tmpvar_26.xy = ((rs_22 / 64.0) + tmpvar_1);\n  tmpvar_26.z = tmpvar_24;\n  xlat_mutablelprof = (texture (sampler_noise_hq, (tmpvar_26.xy / 4.0)) - 0.75).x;\n  xlat_mutablelprof = (xlat_mutablelprof + (texture (sampler_noise_hq, (tmpvar_26.xy / 2.0)) / 2.0).x);\n  lav_gnd = (lav_gnd - ((xlat_mutablelprof / 3.0) * 0.2));\n  xlat_mutablelavmod = (texture (sampler_noise_hq, vec2((tmpvar_26.x / 16.0))) - 0.5).x;\n  xlat_mutablelprof = (xlat_mutablelprof + xlat_mutablelavmod);\n  xlat_mutablersl2 = (tmpvar_26 + vec3(0.0, 0.03, 0.0));\n  xlat_mutablelprof2 = (texture (sampler_noise_hq, (xlat_mutablersl2.xy / 4.0)) - 0.75).x;\n  xlat_mutablelprof2 = (xlat_mutablelprof2 + (texture (sampler_noise_hq, (xlat_mutablersl2.xy / 2.0)) / 2.0).x);\n  xlat_mutablelprof2 = (xlat_mutablelprof2 + xlat_mutablelavmod);\n  vec2 x_27;\n  x_27 = (xlat_mutableuv2 - sunpos);\n  vec2 rs_28;\n  float z_29;\n  float tmpvar_30;\n  tmpvar_30 = (10.0 - q8);\n  z_29 = (tmpvar_30 / (tmpvar_11.y - sky_gnd));\n  float tmpvar_31;\n  tmpvar_31 = clamp (z_29, -150.0, 16.0);\n  z_29 = tmpvar_31;\n  rs_28.x = ((tmpvar_11.x * 2.0) * tmpvar_31);\n  rs_28.y = tmpvar_31;\n  mat2 tmpvar_32;\n  tmpvar_32[uint(0)].x = q3;\n  tmpvar_32[uint(0)].y = tmpvar_9;\n  tmpvar_32[1u].x = q4;\n  tmpvar_32[1u].y = q3;\n  rs_28 = (rs_28 * tmpvar_32);\n  vec3 tmpvar_33;\n  tmpvar_33.xy = ((-(rs_28) / 64.0) + (tmpvar_1 / 4.0));\n  tmpvar_33.z = tmpvar_31;\n  vec3 uvi_34;\n  uvi_34.xy = tmpvar_33.xy;\n  uvi_34.z = 0.0;\n  xlat_mutablesky_gnd = (sky_gnd - ((\n    clamp ((mix (dot (texture (sampler_noisevol_hq, uvi_34), vec4(0.32, 0.49, 0.29, 0.0)), dot (texture (sampler_noisevol_hq, \n      (uvi_34 * 4.0)\n    ), vec4(0.32, 0.49, 0.29, 0.0)), q31) - q10), 0.0, 1.0)\n   / tmpvar_31) * 2.0));\n  vec2 rs_35;\n  float z_36;\n  z_36 = (tmpvar_30 / (tmpvar_11.y - xlat_mutablesky_gnd));\n  float tmpvar_37;\n  tmpvar_37 = clamp (z_36, -150.0, 16.0);\n  z_36 = tmpvar_37;\n  rs_35.x = ((tmpvar_11.x * 2.0) * tmpvar_37);\n  rs_35.y = tmpvar_37;\n  mat2 tmpvar_38;\n  tmpvar_38[uint(0)].x = q3;\n  tmpvar_38[uint(0)].y = tmpvar_9;\n  tmpvar_38[1u].x = q4;\n  tmpvar_38[1u].y = q3;\n  rs_35 = (rs_35 * tmpvar_38);\n  vec3 tmpvar_39;\n  tmpvar_39.xy = ((-(rs_35) / 64.0) + (tmpvar_1 / 4.0));\n  tmpvar_39.z = tmpvar_37;\n  vec3 uvi_40;\n  uvi_40.xy = tmpvar_39.xy;\n  uvi_40.z = 0.0;\n  float tmpvar_41;\n  tmpvar_41 = clamp ((mix (\n    dot (texture (sampler_noisevol_hq, uvi_40), vec4(0.32, 0.49, 0.29, 0.0))\n  , \n    dot (texture (sampler_noisevol_hq, (uvi_40 * 4.0)), vec4(0.32, 0.49, 0.29, 0.0))\n  , q31) - q10), 0.0, 1.0);\n  xlat_mutablesky_gnd = (xlat_mutablesky_gnd - ((tmpvar_41 / tmpvar_37) * 2.0));\n  vec2 rs_42;\n  float z_43;\n  z_43 = ((2.0 / tmpvar_11.y) * (q8 - (4.0 * lav_gnd)));\n  float tmpvar_44;\n  tmpvar_44 = clamp (z_43, -0.1, tmpvar_7);\n  z_43 = tmpvar_44;\n  rs_42.x = ((tmpvar_11.x * 2.0) * tmpvar_44);\n  rs_42.y = tmpvar_44;\n  mat2 tmpvar_45;\n  tmpvar_45[uint(0)].x = q3;\n  tmpvar_45[uint(0)].y = tmpvar_9;\n  tmpvar_45[1u].x = q4;\n  tmpvar_45[1u].y = q3;\n  rs_42 = (rs_42 * tmpvar_45);\n  vec3 tmpvar_46;\n  tmpvar_46.xy = ((rs_42 / 64.0) + tmpvar_1);\n  tmpvar_46.z = tmpvar_44;\n  xlat_mutablersl = (8.0 * tmpvar_46);\n  vec3 uvi_47;\n  uvi_47.xy = xlat_mutablersl.xy;\n  float z_48;\n  float k3_49;\n  float k2_50;\n  z_48 = (xlat_mutablersl.z / 2048.0);\n  float tmpvar_51;\n  tmpvar_51 = clamp ((1.0 - (z_48 / 2.0)), 0.0, 1.0);\n  k2_50 = (clamp ((1.0 - \n    (z_48 * 2.0)\n  ), 0.0, 1.0) / 2.0);\n  k3_49 = (clamp ((1.0 - \n    (z_48 * 4.0)\n  ), 0.0, 1.0) / 4.0);\n  uvi_47.z = (0.01 * time);\n  xlat_mutablenoise = ((pow (\n    ((((\n      dot (texture (sampler_noisevol_hq, (uvi_47 * float((tmpvar_51 >= 0.0)))), vec4(0.32, 0.49, 0.29, 0.0))\n     * tmpvar_51) + (\n      dot (texture (sampler_noisevol_hq, ((uvi_47 * 2.0) * float((k2_50 >= 0.0)))), vec4(0.32, 0.49, 0.29, 0.0))\n     * k2_50)) + (dot (texture (sampler_noisevol_hq, \n      ((uvi_47 * 4.0) * float((k3_49 >= 0.0)))\n    ), vec4(0.32, 0.49, 0.29, 0.0)) * k3_49)) - (((tmpvar_51 + k2_50) + k3_49) / 2.0))\n  , q11) / q8) * 2.0);\n  xlat_mutablelava = mix (vec4(0.7, 0.7, 0.7, 0.7), texture (sampler_noise_hq, ((\n    (xlat_mutablersl + (xlat_mutablenoise / 2.0))\n   * rand_preset.x) / 2.0).xy), vec4(q14)).x;\n  xlat_mutablelava = (xlat_mutablelava * mix (xlat_mutablelprof, 1.0, q13));\n  xlat_mutablelava = (xlat_mutablelava * (1.0 + (\n    (pow (texture (sampler_noise_hq, (xlat_mutablelprof + (xlat_mutablersl / 4.0)).xy), vec4(6.0, 6.0, 6.0, 6.0)) * 0.25)\n  .x * texture (sampler_noise_hq, \n    (tmpvar_26 / 16.0)\n  .xy).x)));\n  xlat_mutablestone = ((1.0 - xlat_mutablelava) * xlat_mutablenoise);\n  xlat_mutablelavmask = (clamp ((hordist - \n    (xlat_mutablersl.z / 200.0)\n  ), 0.0, 1.0) * float((xlat_mutablersl.z >= 0.0)));\n  float tmpvar_52;\n  tmpvar_52 = clamp ((1.0 - xlat_mutablelavmask), 0.0, 1.0);\n  float tmpvar_53;\n  tmpvar_53 = clamp (((-16.0 / tmpvar_37) - 0.1), 0.0, 1.0);\n  xlat_mutablecloud = (((1.0 - tmpvar_41) * tmpvar_53) * tmpvar_52);\n  float tmpvar_54;\n  tmpvar_54 = clamp ((1.0 - (5.0 * xlat_mutablecloud)), 0.0, 1.0);\n  float tmpvar_55;\n  tmpvar_55 = (clamp (q15, 0.0, 1.0) + 0.01);\n  float tmpvar_56;\n  tmpvar_56 = clamp (((tmpvar_55 * \n    (0.2 + q30)\n  ) * 3.0), 0.0, 1.0);\n  vec2 tmpvar_57;\n  tmpvar_57.y = 0.1;\n  tmpvar_57.x = q17;\n  vec2 x_58;\n  x_58 = (xlat_mutableuv2 - tmpvar_57);\n  vec2 tmpvar_59;\n  tmpvar_59 = (xlat_mutableuv2 - planpos);\n  float tmpvar_60;\n  tmpvar_60 = (12.0 * sqrt(dot (tmpvar_59, tmpvar_59)));\n  vec2 tmpvar_61;\n  tmpvar_61 = ((sin(tmpvar_60) / cos(tmpvar_60)) * normalize(tmpvar_59));\n  float tmpvar_62;\n  tmpvar_62 = clamp ((32.0 - (22.0 * tmpvar_60)), 0.0, 1.0);\n  vec3 tmpvar_63;\n  tmpvar_63 = ((1.0 + slow_roam_cos) / 2.0).xyz;\n  xlat_mutableret1 = ((tmpvar_56 / sqrt(\n    dot (x_58, x_58)\n  )) * tmpvar_63);\n  xlat_mutableret1 = (xlat_mutableret1 + (clamp (\n    (0.02 / sqrt(dot (x_27, x_27)))\n  , 0.0, 1.0) * tmpvar_54));\n  xlat_mutableret1 = (xlat_mutableret1 * tmpvar_52);\n  float t_64;\n  t_64 = (0.1 + q13);\n  vec3 tmpvar_65;\n  tmpvar_65.x = t_64;\n  tmpvar_65.y = pow (t_64, 2.2);\n  tmpvar_65.z = pow (t_64, 5.0);\n  vec3 tmpvar_66;\n  tmpvar_66 = clamp ((tmpvar_65 / vec3(0.8, 0.8, 0.8)), 0.0, 1.0);\n  vec3 tmpvar_67;\n  tmpvar_67 = ((tmpvar_66 * (tmpvar_66 * \n    (3.0 - (2.0 * tmpvar_66))\n  )) + 0.1);\n  xlat_mutableret1 = (xlat_mutableret1 + ((\n    ((tmpvar_63 * xlat_mutablecloud) * tmpvar_56)\n   * \n    (1.0 - q10)\n  ) + (tmpvar_67 * xlat_mutablecloud)));\n  float tmpvar_68;\n  tmpvar_68 = clamp ((xlat_mutablelava - tmpvar_56), 0.0, 1.0);\n  vec3 tmpvar_69;\n  tmpvar_69.x = tmpvar_68;\n  tmpvar_69.y = pow (tmpvar_68, 2.2);\n  tmpvar_69.z = pow (tmpvar_68, 5.0);\n  vec3 tmpvar_70;\n  tmpvar_70 = clamp ((tmpvar_69 / vec3(0.8, 0.8, 0.8)), 0.0, 1.0);\n  xlat_mutableret1 = (xlat_mutableret1 + ((tmpvar_70 * \n    (tmpvar_70 * (3.0 - (2.0 * tmpvar_70)))\n  ) * xlat_mutablelavmask));\n  xlat_mutableret1 = (xlat_mutableret1 + ((xlat_mutablestone * xlat_mutablelavmask) * (tmpvar_67 + \n    (0.5 * tmpvar_56)\n  )));\n  xlat_mutableret1 = (xlat_mutableret1 + ((\n    ((((0.5 + xlat_mutablestone) * (xlat_mutablelprof2 - xlat_mutablelprof)) * xlat_mutablelavmask) * clamp ((tmpvar_55 * 4.0), 0.0, 1.0))\n   * \n    (1.0 + tmpvar_63)\n  ) / 2.0));\n  fl_2 = ((8.0 * clamp (xlat_mutablestone, 0.0, 1.0)) * xlat_mutablelavmask);\n  fl_2 = (fl_2 + ((4.0 * \n    clamp ((1.0 - tmpvar_41), 0.0, 1.0)\n  ) * tmpvar_53));\n  xlat_mutableret1 = (xlat_mutableret1 + ((fl_2 * vec3(0.7, 0.4, 1.0)) * q21));\n  xlat_mutableret1.z = (xlat_mutableret1.z + ((\n    (xlat_mutablelavmask * clamp (-(q15), 0.0, 1.0))\n   * \n    clamp ((-(q13) * 2.0), 0.0, 1.0)\n  ) * uv.y));\n  xlat_mutableret1 = (xlat_mutableret1 + ((\n    (((tmpvar_52 * clamp (\n      (-1.0 + dot (((tmpvar_61 * \n        (1.0 + abs((texture (sampler_noise_hq, (tmpvar_61 / 2.0)) - 0.5)).x)\n      ) * tmpvar_62), normalize((sunpos - planpos))))\n    , -0.1, 4.0)) * tmpvar_62) / 2.0)\n   * tmpvar_54) * (1.0 - tmpvar_56)));\n  vec3 tmpvar_71;\n  tmpvar_71 = mix (xlat_mutableret1, mix (tmpvar_67, vec3(1.0, 1.0, 1.0), vec3(tmpvar_56)), vec3(((\n    clamp ((1.0 - (8.0 * abs(\n      (uv.y - 0.04)\n    ))), 0.0, 1.0)\n   / q29) * q12)));\n  xlat_mutableret1 = tmpvar_71;\n  vec4 tmpvar_72;\n  tmpvar_72.w = 1.0;\n  tmpvar_72.xyz = (1.0 - exp((\n    -(tmpvar_71)\n   * 2.0)));\n  ret = tmpvar_72.xyz;\n }","comp":" shader_body { \n  vec3 ret_1;\n  vec2 tmpvar_2;\n  tmpvar_2.y = 0.0;\n  tmpvar_2.x = texsize.z;\n  vec2 tmpvar_3;\n  tmpvar_3 = (tmpvar_2 * 2.0);\n  vec2 tmpvar_4;\n  tmpvar_4.x = 0.0;\n  tmpvar_4.y = texsize.w;\n  vec2 tmpvar_5;\n  tmpvar_5 = (tmpvar_4 * 2.0);\n  vec2 tmpvar_6;\n  tmpvar_6.x = (((texture (sampler_blur1, \n    (uv - tmpvar_3)\n  ).xyz * scale1) + bias1) - ((texture (sampler_blur1, \n    (uv + tmpvar_3)\n  ).xyz * scale1) + bias1)).x;\n  tmpvar_6.y = (((texture (sampler_blur1, \n    (uv - tmpvar_5)\n  ).xyz * scale1) + bias1) - ((texture (sampler_blur1, \n    (uv + tmpvar_5)\n  ).xyz * scale1) + bias1)).x;\n  vec2 tmpvar_7;\n  tmpvar_7 = (tmpvar_6 * 0.5);\n  vec3 tmpvar_8;\n  tmpvar_8 = ((texture (sampler_blur1, fract(\n    (uv + tmpvar_7)\n  )).xyz * scale1) + bias1);\n  vec2 tmpvar_9;\n  tmpvar_9 = (0.2 * cos((\n    (((uv - 0.5) + (tmpvar_7 / 4.0)) * 4.0)\n   + time)));\n  ret_1 = (((texture (sampler_main, \n    (uv + tmpvar_7)\n  ) * texture (sampler_main, \n    ((1.0 - uv) - tmpvar_7)\n  )).xyz + (tmpvar_8 * 2.0)) + ((q21 * vec3(\n    clamp ((0.01 / sqrt(dot (tmpvar_9, tmpvar_9))), 0.0, 1.0)\n  )) * (1.0 - tmpvar_8)));\n  ret_1 = (ret_1 * 0.7);\n  vec4 tmpvar_10;\n  tmpvar_10.w = 1.0;\n  tmpvar_10.xyz = ret_1;\n  ret = tmpvar_10.xyz;\n }","warp_hlsl":"sampler sampler_pw_noise_lq;\nstatic const float quality = 3, depth = .2;\nfloat3 rsl, rsl2, rss, ret1, rs2,rs3;\nfloat2 dz, uv0, uv1, uv2, uv3, uv4, dz1,tmp2, ditch2;\nfloat  ditch,lprof,lprof2,sprof,sprof2, n,noise, stone,stone_lit,sun,cloud,sky,lava,hor;\nfloat flashmask, hormask, lavmask,ilavmask,lavmask_s,cldmask,lavmod;\nstatic float lav_gnd = 0,hordist = (3+q8), tele = q29, sky_gnd = q16;\nstatic float2 mov = float2 (q5,q6), sunpos = float2(q17,q18), planpos = float2(q17+.5,q32);\nstatic float3 skycol = float3 (.1,.1,.2);\nfloat3 lavcol (float t) {return smoothstep(0,.8,float3(t,pow(t,2.2),pow(t,5)));}\nfloat nmod (float2 uvi) {return lerp(.7,tex2D (sampler_noise_hq,uvi),q14);} \n\nfloat flash (float2 uvi) {return .5/pow(abs(uvi.x),.5);}\nfloat hq_n (float3 uvi) {return lum(tex3D (sampler_noisevol_hq ,uvi));}\nfloat noise4 (float3 uvi) { float tmp,k1,k2,k3,k4,z;\n  z = uvi.z/2048;\n  k1 = saturate(1-z/2); k2 = saturate(1-z*2)/2; k3 = saturate(1-z*4)/4 ; k4 = saturate(1-z*8)/4*0 ;\n  float mean = k1+k2 + k3 + k4; \n  uvi.z = .01*time; \n  tmp2 = hq_n(uvi*(k1>=0))*k1+hq_n(uvi*2*(k2>=0))*k2\n  +hq_n(uvi*4*(k3>=0))*k3+hq_n(uvi*8*(k4>=0))*k4 -mean/2;\n  return tmp2;}\n\nfloat noise2 (float3 uvi) {uvi.z=0; return saturate(lerp(hq_n(uvi),hq_n(uvi*4),q31)-q10);}\n\nfloat3 rs_lav (float2 uvi, float berg) {  float z; float2 rs;\n//  uvi.y += .06*lum(tex2D (sampler_noise_hq,(uv1.x*.06-q9*.04)))-.015;\n  z = 2/(uvi.y)*(q8-4*berg); z = clamp(z,-.1,32*hordist); //#final check !\n  rs.x = uvi.x*2*z ; rs.y = z;  //rs.x = (uvi.x) * (z+.464/z)*2 ; rs.y = z; //#\n  rs = mul(rs,float2x2(q3,q4,-q4,q3));  \n  return float3(rs/64 + mov,z); } \n\nfloat3 rs_sky (float2 uvi, float berg) {  float z; float2 rs;\n  z = (10-q8)/(uvi.y - berg); z = clamp(z,-150,16);\n  rs.x = (uvi.x)*2*z ; rs.y = z; \n  rs = mul(rs,float2x2(q3,q4,-q4,q3));\n  return float3(-rs/64+mov/4,z); }\n\nshader_body {\nuv1 = uv; uv0 = uv; uv2 = uv1*aspect.xy*tele;\n\nrsl = rs_lav(tele*(float2(uv1.x*0,-.2)),-q8); \nlav_gnd = (tex2D (sampler_noise_hq, rsl/4))*.2/q8-.15; //#\n\nfor (n=1; n <= quality; n++) {\n  rsl = rs_lav(tele*uv1,lav_gnd); //#spiele an uv-Vorfakt - zoom, auch bei sky !\n  lprof =  (tex2D (sampler_noise_hq,rsl.xy/4)) - .75; //mittelwert null !#\n  lprof +=  (tex2D (sampler_noise_hq,rsl.xy/2))/2 ; \n//  lprof +=  (tex2D (sampler_noise_hq,rsl.xy))/4 ; \n  ditch = saturate(6*length(sin(rsl.xy/2+lprof*.0))-7)*0; \n  lprof = lerp(lprof,1,ditch);\n  lav_gnd -= lprof/quality*depth; } //#?\nlavmod = tex2D (sampler_noise_hq,rsl.x/16)-.5;  \nfloat lavmod2 = tex2D (sampler_noise_hq,rsl/16); \nlprof += lavmod;\n\nrsl2 = rsl + float3(0,0.03,0);\nlprof2 = (tex2D (sampler_noise_hq,rsl2.xy/4)) - .75; //mittelwert null !#\nlprof2 +=  (tex2D (sampler_noise_hq,rsl2.xy/2))/2 ; \nlprof2 += lavmod; // ditch fehlt !#\n\nsun = saturate(.02/length(uv2-sunpos)); \n\nrss = rs_sky(tele*uv1,sky_gnd) ; \nsprof = noise2(rss);  sky_gnd -= sprof/rss.z*2;\nrss = rs_sky(tele*uv1,sky_gnd);\nsprof = noise2(rss);  sky_gnd -= sprof/rss.z*2;\n\nfloat3 rss2 = rss + float3(0,.01,0);\nsprof2 = noise2(rss2);\n\nrsl = 8*rs_lav(tele*uv1,lav_gnd); \n\nnoise = pow(noise4(rsl+ditch*lprof),q11)/q8*2; //aliasing reduzieren\nlava = nmod((rsl+noise/2)*rand_preset.x/2)+ditch*0;\nlava *= lerp (lprof,1,q13); //# zusatzglow, blosse addition uebersteuert ditch\nfloat layers = pow(tex2D (sampler_noise_hq,lprof+rsl/4),6)*.25*(1-ditch) ;\nlava *= 1+layers*lavmod2;\n//lava *= .2+saturate(.1/abs(length(sin(rsl.xy/8))-q22));\n\nstone = (1-lava)*noise;\nstone_lit = (lprof2-lprof);\n\n//------------------- masking -----------------------------------------\nlavmask = saturate (hordist-rsl.z/200) * (rsl.z >= 0); // # !\nilavmask = saturate(1-lavmask);\ncldmask = saturate(-16/rss.z-.1);\nhormask = saturate (abs(rss.z)/64)*saturate(2-512/rsl.z);\nhormask = saturate (1-8*abs(uv1.y-.04))/q29;\nflashmask = saturate(hormask*4-2*(1+rand_frame)) ;\ncloud =  (1-sprof)*cldmask*ilavmask;\nfloat ncloud = saturate(1-5*cloud);\n\nfloat k1 = saturate(q15)+.01 ; //durch daytime ersetzen aber nicht negativ oder null#\nfloat daylight = saturate(k1*(.2+q30)*3); \n\nfloat asym = (q30); \nhor = (daylight/length((uv2-float2(q17,.1)))) ;\nsky = ncloud*k1;\n\n\n//----------------Planet----------------\nfloat2 rsk = (uv2 - planpos) ;\nfloat2 dz1 = normalize(rsk);\nfloat rad3 =12*length (rsk);\nfloat2 uv4 =  tan(rad3)*dz1;\nfloat2 noise = abs(tex2D (sampler_noise_hq,uv4/2)-.5);\nfloat mask3 = saturate(32-22*rad3);\nfloat2 Planet = (uv4*(1+noise.x))*mask3;\n\n\n//----------------- colour mixing starts here---fuck--------\n//---------------- skylight first-----------------\nfloat3 col_hor = (1+slow_roam_cos)/2;\nret1 = hor*col_hor; \nret1 += sun*ncloud;\nret1 *= ilavmask;  \n\n//------------ clouds ----------------------\nfloat3 shine = lavcol(.1+q13)+.1;\n//ret1 += shine*cloud/2 + daylight*cloud*(1+col_hor)/4;// bedenke +cloud tagsueber\nret1 += col_hor*(cloud)*daylight*(1-q10) + shine*(cloud);\n\n//----------------lava / stone  -----------------\nret1 += lavcol(saturate(lava-daylight*(1-ditch))) * lavmask ; \nret1 += stone *lavmask*(shine+.5*daylight);\nret1 += (.5+stone)*(1-ditch)*stone_lit*lavmask*saturate(k1*4)*(1+col_hor)/2;\n\n//--------------------flash------------------\nfloat fl = 0;//flashmask*flash(uv1+rand_frame/2-q4+hq_n(float3(8*uv1,q21))*.02);\nfl += 8*saturate(stone)*lavmask;\nfl += 4*saturate(1-sprof)*cldmask;\nret1 += fl*float3(.7,.4,1)*q21;\n\nret1.b += lavmask*saturate(-q15)*saturate(-q13*2)*(uv1.y);\n\n\nret1 = ret1 + ilavmask*clamp(-1+1*dot(Planet,normalize(sunpos-planpos)),-.1,4)\n              *mask3/2*ncloud*(1-daylight);\n//---------------- fog ------------------------------------\nfloat3 fogcol = lerp(shine,1,daylight);\nret1 = lerp(ret1,1*fogcol,hormask*q12); // what the#\n\nk1 = (q29-1)/6;\n//ret1 = lerp(GetPixel(uv_orig)*.7,ret1,1-k1);\nret = 1-exp(-ret1*2); //finally !\n//ret = hormask;\n}\n\nwritten by martin\nEND","comp_hlsl":"shader_body\n{\n\n//uv = (uv-.5) * aspect.xy + .5;\n\n\nfloat2 hor = float2 (texsize.z,0)*2;\nfloat2 ver = float2 (0,texsize.w)*2;\nfloat dx = GetBlur1 (uv-hor) - GetBlur1 (uv+hor);\nfloat dy = GetBlur1 (uv-ver) - GetBlur1 (uv+ver);\nfloat2 dz = float2 (dx,dy)*0.5;\n\n\n\nfloat3 crisp = tex2D(sampler_main, uv + dz) * \n               tex2D(sampler_main, 1-uv - dz);\nfloat3 blur = GetBlur1(frac(uv + dz));\n\nfloat2 uv1 = uv-.5 + dz/4;\nfloat2 uv2 = uv1*0+.2*float2 (cos(uv1*4+time));;\nfloat3 dots = saturate(.01/(length(uv2))) * float3 (1,1,1);\n\n\nret = (crisp + blur*2) + q21*dots * (1-blur);\nret *= .7 ;\n}"}