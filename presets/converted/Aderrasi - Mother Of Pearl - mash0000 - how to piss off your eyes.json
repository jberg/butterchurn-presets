{"version":2,"baseVals":{"rating":0,"gammaadj":1,"decay":0.97,"echo_zoom":1.05,"echo_alpha":0.2,"wave_mode":1,"wave_brighten":0,"wave_a":100,"wave_scale":0.8,"wave_smoothing":0,"wave_mystery":-0.4,"modwavealphastart":0.5,"modwavealphaend":1,"warpscale":100,"zoomexp":0.0228,"dx":0.00001,"dy":0.00001,"warp":0.01,"wave_r":0,"wave_g":0,"wave_b":0,"ob_size":0,"ob_a":1,"ib_size":0.25,"mv_x":0,"mv_y":0,"mv_l":1,"mv_a":0},"shapes":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"","frame_eqs_str":"a.wave_b+=.7*Math.sin(a.bass);a.wave_r-=.8*Math.sin(a.treb);a.wave_g+=.8*Math.sin(a.mid);a.zoom+=.008;a.ob_size+=0*Math.sin(8900*a.time);a.zoomexp+=.00001<Math.abs(above(a.bass,1))?.025:.099;a.rot+=.00001<Math.abs(above(a.bass,1))?.01:-.01;a.warp+=.00001<Math.abs(above(a.treb,1))?.5:-.5;a.dy+=.00001<Math.abs(above(a.mid,1.5))?.01:-.0025;","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"wave_b = wave_b + 0.7*sin(bass);\nwave_r = wave_r - 0.8*sin(treb);\nwave_g = wave_g +0.8*sin(mid);\nzoom = zoom + 0.008;\nob_size = ob_size + 0.00*sin(8900*time);\nzoomexp = zoomexp + if (above(bass,1), 0.025, 0.099);\nrot = rot + if (above(bass,1), +0.01, -0.01);\nwarp = warp + if(above(treb,1), +0.5, -0.5);\ndy = dy + if(above(mid,1.5), +0.01, -0.0025);","pixel_eqs_eel":"","warp":" shader_body { \n  vec3 ret_1;\n  vec2 tmpvar_2;\n  tmpvar_2.x = (((\n    ((texture (sampler_blur2, (uv + vec2(0.01, 0.0))).xyz * scale2) + bias2)\n   - \n    ((texture (sampler_blur2, (uv - vec2(0.01, 0.0))).xyz * scale2) + bias2)\n  ).y * 1280.0) * texsize.z);\n  tmpvar_2.y = (((\n    ((texture (sampler_blur2, (uv + vec2(0.0, 0.01))).xyz * scale2) + bias2)\n   - \n    ((texture (sampler_blur2, (uv - vec2(0.0, 0.01))).xyz * scale2) + bias2)\n  ).y * 1024.0) * texsize.w);\n  ret_1.y = texture (sampler_fw_main, (uv + (tmpvar_2 * 0.005))).y;\n  ret_1 = (ret_1 + ((\n    (ret_1 - ((texture (sampler_blur3, uv).xyz * scale3) + bias3))\n   * 0.3) - 0.05));\n  ret_1 = (ret_1 + ((texture (sampler_noise_lq, \n    (((uv_orig * texsize.xy) * (texsize_noise_lq.zw * 0.25)) + rand_frame.xy)\n  ).xyz - 0.5) * 0.1));\n  ret_1 = mix (ret_1, vec3(dot (ret_1, vec3(0.32, 0.49, 0.29))), vec3(0.2, 0.2, 0.2));\n  vec4 tmpvar_3;\n  tmpvar_3.w = 1.0;\n  tmpvar_3.xyz = ret_1;\n  ret = tmpvar_3.xyz;\n }","comp":"","warp_hlsl":"sampler sampler_cells;\n \nshader_body\n{\n\n    float1 d = 0.01;\n    float1 dx = ( GetBlur2(uv + float2(d,0)) - GetBlur2(uv-float2(d,0)) ).y*1280*texsize.z;\n    float1 dy = ( GetBlur2(uv + float2(0,d)) - GetBlur2(uv-float2(0,d)) ).y*1024*texsize.w;\n    float2 my_uv = uv + float2(dx,dy)*0.005;\n\n\n\n//    float1 v = 0.01;\n    ret.y = tex2D( sampler_fw_main, my_uv).y;\n\n    \n//ret = 0;\n//   ret = tex2D( sampler_cells, uv)/ lerp(ret,tex2D(sampler_main,uv_orig-my_uv+uv),0.3);\n      // take the difference between the crisp and blurred images,\n      // then add it back into the image.  Creates spots and stripes over time.\n      ret.xyz += (ret - GetBlur3(uv-floor(uv)*0))*0.3 - 0.05;\n      ret.xyz *= 1;\n\n      // add noise:\n      float2 dither_uv = uv_orig*texsize.xy*texsize_noise_lq.zw * 0.25 + rand_frame.xy;\n      ret.xyz += (tex2D(sampler_noise_lq, dither_uv).xyz-0.5)*0.1;\n\n      // desaturate over time, to keep the globs white\n      ret.xyz = lerp(ret.xyz, lum(ret.xyz), 0.2);\n}","comp_hlsl":""}