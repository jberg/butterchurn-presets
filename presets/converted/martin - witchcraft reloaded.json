{"version":2,"baseVals":{"rating":3,"gammaadj":1.98,"decay":0.5,"echo_zoom":1,"echo_alpha":0.5,"echo_orient":3,"wave_mode":6,"wave_thick":1,"modwavealphabyvolume":1,"wave_brighten":0,"darken":1,"wave_a":0.001,"wave_scale":0.527,"wave_smoothing":0.09,"modwavealphastart":0,"modwavealphaend":1.32,"warpanimspeed":1.459,"warpscale":2.007,"zoom":0.9999,"warp":0.01,"sx":0.9999,"wave_r":0.8,"wave_g":0.49,"ob_a":1,"ib_size":0.26,"mv_x":64,"mv_y":48,"mv_l":1.85,"mv_r":0.5,"mv_g":0.5,"mv_b":0.5,"mv_a":0,"b2x":0.7,"b1ed":0},"shapes":[{"baseVals":{"enabled":1,"sides":12,"num_inst":1024,"rad":0.03632,"tex_ang":1.00531,"tex_zoom":1.53117,"b":1,"a":0,"g2":0,"border_b":0,"border_a":0},"init_eqs_eel":"","frame_eqs_eel":"fov = reg03;\nn = instance*reg00;\n\n\nx0 = gmegabuf(n);\ny0 = gmegabuf(n+1);\nz0 = gmegabuf(n+2)+reg02;\n\nx = x0/z0*fov + 0.5;\ny = y0/z0*q32*fov + 0.5;\n\n\n//k1 = reg01+t1;\nr = gmegabuf(n+3);\ng = gmegabuf(n+4);\nb = gmegabuf(n+5);\nr2 = r/2; g2 = g/2; b2 = b2/2;\n\na = instance/1024; a2 = a*.5;\nrad = min(0.02/z0,.5) * (z0 > 0)*2.5*sqrt(a);\nrad *= gmegabuf(n+6);\n\nt1 -= 1;\n"},{"baseVals":{"num_inst":128,"x":0.26,"y":0.2,"rad":0.39317,"tex_zoom":0.9355,"g":1,"b":0.6,"g2":0,"border_r":0,"border_g":0,"border_b":0,"border_a":0,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"sides":13,"additive":1,"num_inst":5,"x":0.65,"y":0.38,"rad":0.57049,"tex_zoom":0.73678,"a":0.7,"g2":0,"border_r":0.5,"border_g":0.5,"border_b":0,"border_a":0,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"sides":14,"additive":1,"thickoutline":1,"textured":1,"x":0.6,"y":0.55,"rad":0.97237,"ang":1.25664,"tex_zoom":0.34933,"g":0.6,"g2":0,"b2":1,"border_r":0.2,"border_g":0.7,"border_b":0.5,"border_a":0,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":1,"scaling":2.15542,"smoothing":0.2,"r":0,"a":0.7},"init_eqs_eel":"","frame_eqs_eel":"t1 = 1023;\nt2 = 0;","point_eqs_eel":"fov = reg03;\nn = t1 * reg00;\n\n\nx0 = gmegabuf(n);\ny0 = gmegabuf(n+1);\nz0 = gmegabuf(n+2)+reg02;\n\nx = x0/z0*fov + 0.5;\ny = y0/z0*fov + 0.5;\n\n\na= max(0,t1/1024);\n\nk1 = reg01+t1;\nr = gmegabuf(n+3);\ng = gmegabuf(n+4);\nb = gmegabuf(n+5);\n\n\na = t1/1024 * (z0 >= 0.5)/2;\n\nt1 -= 1;\ngmegabuf (10000 +t2) = abs(value1+value2);\nt2 += 1;"},{"baseVals":{"enabled":1,"scaling":0.89152,"smoothing":0.82,"r":0,"a":0.1},"init_eqs_eel":"","frame_eqs_eel":"t1 = 512;","point_eqs_eel":"fov = reg03;\nn = t1 * reg00;\n\n\nx0 = gmegabuf(n);\ny0 = gmegabuf(n+1);\nz0 = gmegabuf(n+2)+reg02;\n\nx = x0/z0*fov + 0.5;\ny = y0/z0*fov + 0.5;\n\nr = gmegabuf(n+3);\ng = gmegabuf(n+4);\nb = gmegabuf(n+5);\n\na= t1/1024* (z0 >= 0.5)/2;\nt1 -= 1;\n"},{"baseVals":{"samples":32,"scaling":0.89152,"smoothing":0.82,"r":0,"g":0.2,"b":0.6,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"spectrum":1,"usedots":1,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_eel":"index = 0;\nloop (100000,\n  megabuf(index) = 0;\n  gmegabuf(index) = 0;\n  index = index + 1;\n);\n\nrecsize = 8;\nreg00 = recsize;\n\npoints = 512*2;\n\nreg01 = 0; //benoetigt fuer \"new\"\nzofs = 1 + rand(100)/100*2; reg02 = zofs;\n\nfov = .3; reg03 = fov;","frame_eqs_eel":"dec_f = pow (0.3, 30/fps);\ndec_m = pow (0.85, 30/fps);\ndec_s = pow (0.95, 30/fps);\nbeat = (bass + mid+ treb)-(bass_att + mid_att+ treb_att) + (bass+mid+treb);\nbeat /= 3;\n\npeak = peak*dec_m + (1-dec_m)*pow(beat-1,1)*(beat>1)*4;\nis_beat = above(beat, 1) * above (time, t0+.2);\nt0 = is_beat*time + (1-is_beat)*t0;\nindex = (index + is_beat) %8;\nindex2 = (index2 + is_beat*bnot(index)) %8;\n\nif (is_beat,\n  ran1 = rand(100)/50-1;\n  ran2 = rand(100)/50-1;\n  ran3 = rand(100)/50-1;\n,0);\nran1_ = dec_m * ran1_ + (1-dec_m) * ran1;\nran2_ = dec_m * ran2_ + (1-dec_m) * ran2;\nran3_ = dec_m * ran3_ + (1-dec_m) * ran3;\nrsum = sqrt(ran1_*ran1_ + ran2_*ran2_ + ran3_*ran3_);\n\nif (is_beat * (index==2),\n  ran4 = (rand(100)/50-1);\n  ran5 = (rand(100)/50-1);\n  ran6 = (rand(100)/50-1);\n,0;);\nran4_ = dec_m * ran4_ + (1-dec_m) * ran4;\nran5_ = dec_m * ran5_ + (1-dec_m) * ran5;\nran6_ = dec_m * ran6_ + (1-dec_m) * ran6;\n\nif (is_beat * (index==6),\n  ran7 = (rand(100)/50-1) ;\n  ran8 = (rand(100)/50-1) ;\n  ran9 = (rand(100)/50-1) ;\n,0;);\nran7_ = dec_m * ran7_ + (1-dec_m) * ran7;\nran8_ = dec_m * ran8_ + (1-dec_m) * ran8;\nran9_ = dec_m * ran9_ + (1-dec_m) * ran9;\n\n\n//Neue Punkte #####################\npk = sqrt(peak+.1);\nNew = int(12*(ran4-ran5)*pk-12*(ran3-ran1)/pk); //##spielen\nnew = max(min (new,20),2);\nreg01 += new;\n\ndec = dec_m;\n\n//Neue Punkte oberhalb des Arrays\nn = recsize*points; m = 0;\ndt1 = (if (ran1>0,4*pk,4/pk))/fps*new/6;\nvol = max(ran1+ran2,.2)*pk*2;\nloop (new,\n  trel1 = trel1 + dt1;\n  x0 = x0 * dec + (1-dec)* (sin(trel1+ran3*6)*vol    +ran1);\n  y0 = y0 * dec + (1-dec)* (sin(trel1+ran2*6)*vol    +ran2);\n  z0 = z0 * dec + (1-dec)* (sin(trel1+ran1*6)*vol +ran3);\n\n  gmegabuf(n)   = x0;\n  gmegabuf(n+1) = y0;\n  gmegabuf(n+2) = z0;\n//Farben\n  gmegabuf(n+3) = ran1_/rsum/3+.5;\n  gmegabuf(n+4) = ran2_/rsum/3+.5;\n  gmegabuf(n+5) = ran3_/rsum/3+.5;\n//Groesse\n  gmegabuf(n+6) = gmegabuf(10000+m)*0+1;;\n  n += recsize; m+=1;);\n\n//Nach unten um \"new\" points umkopieren\nn = 0;\nloop (recsize*points,\n  gmegabuf (n) = gmegabuf(n+new*recsize) ;\n  n += 1;);\n\nxang = ran4_/fps;\nyang = ran5_/fps;\nzang = ran6_/fps;\nddx = min(max(ddx+yang/fps,-1),1);\nddy = min(max(ddy+xang/fps,-1),1);\nq1 = ddx*2;\nq2 = ddy*2;\n//Rotieren\nn = 0;\nloop (points,\n  ox = gmegabuf (n);\n  oy = gmegabuf (n+1);\n  oz = gmegabuf (n+2);\n  mx = ox*cos(zang) - oy*sin(zang);\n  my = ox*sin(zang) + oy*cos(zang);\n  ox = mx;  oy = my;\n  mx = ox*cos(yang) + oz*sin(yang);\n  mz = -ox*sin(yang) + oz*cos(yang);\n  ox = mx;  oz = mz;\n  my = oy*cos(xang) - oz*sin(xang);\n  mz = oy*sin(xang) + oz*cos(xang);\n  oy = my;  oz = mz;\n  gmegabuf (n) = ox;\n  gmegabuf (n+1) = oy;\n  gmegabuf (n+2) = oz;\nn += recsize;);\n\n\n//SPIEL\nk1 = ran7_/fps/2;\nk2 = ran8_/fps/2;\nk3 = abs(ran9_)/fps;\n\ndec = .4 + .6*ran5_; dec2 = (1-dec);\nr1 = .5+.3*ran4_;\nn = 0;\nloop (points-1,\n  m = n*recsize;\n  left  =  ((n-1+points)%points) * recsize;\n  right =  ((n+1+points)%points) * recsize;\n  gmegabuf (m) =   dec*gmegabuf(m)   + dec2*(gmegabuf(left)*r1   +gmegabuf(right)*(1-r1) + k1) ;\n  gmegabuf (m+1) = dec*gmegabuf(m+1) + dec2*(gmegabuf(left+1)*r1 +gmegabuf(right+1)*(1-r1) + k2) ;\n//  gmegabuf (m+2) = dec*gmegabuf(m+2) + dec2*(gmegabuf(left+2)*r1 +gmegabuf(right+2)*(1-r1) + k3) ;\n  n += 1;\n);\n\n\nm = (frame%points);\nm = max(0,int(1024 + (t0-time)*200));\nn = m * recsize;\nq5 = gmegabuf(n)/(gmegabuf(n+2)+zofs)*fov;\nq6 = -gmegabuf(n+1)/(gmegabuf(n+2)+zofs)*fov;\n\nq10=  sqrt(gmegabuf (n+3));\nq11=  sqrt(gmegabuf(n+4));\nq12=  sqrt(gmegabuf (n+5));\n\n\nmonitor =   m;\n\nq32 = aspecty;","pixel_eqs_eel":"rot = 0; zoom = 1; warp = 0; dy = .00; dx = -.00;","warp":" shader_body { \n  vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xyz = vec3(0.0, 0.0, 0.0);\n  ret = tmpvar_1.xyz;\n }","comp":"float xlat_mutablesmask;\nvec2 xlat_mutableuv1;\nvec2 xlat_mutableuv2;\nvec2 xlat_mutableuv3;\nvec2 xlat_mutableuv4;\n shader_body { \n  float flash_1;\n  float dist_2;\n  float stars_3;\n  vec3 ret_4;\n  xlat_mutableuv1 = ((uv - 0.5) * aspect.xy);\n  float tmpvar_5;\n  tmpvar_5 = (0.1 * time);\n  float tmpvar_6;\n  tmpvar_6 = (0.2 * rad);\n  dist_2 = ((1.0 - fract(\n    (0.3333333 + tmpvar_5)\n  )) * (1.0 - tmpvar_6));\n  vec2 tmpvar_7;\n  tmpvar_7.x = q1;\n  tmpvar_7.y = q2;\n  xlat_mutableuv3 = (xlat_mutableuv1 + tmpvar_7);\n  xlat_mutableuv4 = ((32.0 * dist_2) * xlat_mutableuv3);\n  xlat_mutablesmask = (texture (sampler_pw_noise_lq, (xlat_mutableuv4 / 256.0)).y - 0.9);\n  vec2 tmpvar_8;\n  tmpvar_8 = abs((fract(xlat_mutableuv4) - 0.5));\n  stars_3 = max (0.0, clamp ((\n    (1.0 - dist_2)\n   * \n    ((0.1 / sqrt(dot (tmpvar_8, tmpvar_8))) * xlat_mutablesmask)\n  ), 0.0, 1.0));\n  dist_2 = ((1.0 - fract(\n    (0.6666667 + tmpvar_5)\n  )) * (1.0 - tmpvar_6));\n  vec2 tmpvar_9;\n  tmpvar_9.x = q1;\n  tmpvar_9.y = q2;\n  xlat_mutableuv3 = (xlat_mutableuv1 + tmpvar_9);\n  xlat_mutableuv4 = ((32.0 * dist_2) * xlat_mutableuv3);\n  xlat_mutablesmask = (texture (sampler_pw_noise_lq, (xlat_mutableuv4 / 256.0)).y - 0.9);\n  vec2 tmpvar_10;\n  tmpvar_10 = abs((fract(xlat_mutableuv4) - 0.5));\n  stars_3 = (stars_3 + max (stars_3, clamp (\n    ((1.0 - dist_2) * ((0.1 / sqrt(\n      dot (tmpvar_10, tmpvar_10)\n    )) * xlat_mutablesmask))\n  , 0.0, 1.0)));\n  dist_2 = ((1.0 - fract(\n    (1.0 + tmpvar_5)\n  )) * (1.0 - tmpvar_6));\n  vec2 tmpvar_11;\n  tmpvar_11.x = q1;\n  tmpvar_11.y = q2;\n  xlat_mutableuv3 = (xlat_mutableuv1 + tmpvar_11);\n  xlat_mutableuv4 = ((32.0 * dist_2) * xlat_mutableuv3);\n  xlat_mutablesmask = (texture (sampler_pw_noise_lq, (xlat_mutableuv4 / 256.0)).y - 0.9);\n  vec2 tmpvar_12;\n  tmpvar_12 = abs((fract(xlat_mutableuv4) - 0.5));\n  stars_3 = (stars_3 + max (stars_3, clamp (\n    ((1.0 - dist_2) * ((0.1 / sqrt(\n      dot (tmpvar_12, tmpvar_12)\n    )) * xlat_mutablesmask))\n  , 0.0, 1.0)));\n  vec2 tmpvar_13;\n  tmpvar_13.x = q5;\n  tmpvar_13.y = q6;\n  xlat_mutableuv2 = (xlat_mutableuv1 - tmpvar_13);\n  float tmpvar_14;\n  tmpvar_14 = ((0.01 / sqrt(\n    dot (xlat_mutableuv2, xlat_mutableuv2)\n  )) * min (3.0, (\n    ((mid - 0.5) * float((mid > 0.5)))\n   * 2.0)));\n  flash_1 = tmpvar_14;\n  float angle_15;\n  float tmpvar_16;\n  tmpvar_16 = abs(xlat_mutableuv2.x);\n  if ((xlat_mutableuv2.y >= 0.0)) {\n    angle_15 = (1.0 - ((xlat_mutableuv2.y - tmpvar_16) / (xlat_mutableuv2.y + tmpvar_16)));\n  } else {\n    angle_15 = (3.0 - ((xlat_mutableuv2.y + tmpvar_16) / (tmpvar_16 - xlat_mutableuv2.y)));\n  };\n  angle_15 = (angle_15 * 0.25);\n  float tmpvar_17;\n  if ((xlat_mutableuv2.x < 0.0)) {\n    tmpvar_17 = -(angle_15);\n  } else {\n    tmpvar_17 = angle_15;\n  };\n  flash_1 = (tmpvar_14 * (tmpvar_14 / (\n    abs((fract((\n      (3.0 * tmpvar_17)\n     + \n      (time * 2.0)\n    )) - 0.5))\n   + 0.18)));\n  vec3 tmpvar_18;\n  tmpvar_18 = max ((texture (sampler_main, uv).xyz * 2.0), ((\n    (texture (sampler_blur2, uv).xyz * scale2)\n   + bias2) * 2.0));\n  vec2 tmpvar_19;\n  tmpvar_19 = sin(xlat_mutableuv3);\n  ret_4 = (clamp ((0.025 / \n    sqrt(dot (tmpvar_19, tmpvar_19))\n  ), 0.0, 1.0) * vec3(0.4, 0.1, 1.0));\n  ret_4 = (ret_4 + clamp ((stars_3 * stars_3), 0.0, 1.0));\n  ret_4 = (ret_4 * clamp ((1.0 - \n    (2.0 * dot (tmpvar_18, vec3(0.32, 0.49, 0.29)))\n  ), 0.0, 1.0));\n  ret_4 = (ret_4 + tmpvar_18);\n  vec3 tmpvar_20;\n  tmpvar_20.x = q10;\n  tmpvar_20.y = q11;\n  tmpvar_20.z = q12;\n  ret_4 = (ret_4 + ((2.0 * \n    clamp (flash_1, 0.0, 1.0)\n  ) * tmpvar_20));\n  vec4 tmpvar_21;\n  tmpvar_21.w = 1.0;\n  tmpvar_21.xyz = ret_4;\n  ret = tmpvar_21.xyz;\n }"}