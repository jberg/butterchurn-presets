{"version":2,"baseVals":{"rating":3,"gammaadj":1,"wave_thick":1,"wrap":0,"wave_a":0.004,"wave_scale":0.037,"wave_smoothing":0,"wave_mystery":-0.44,"modwavealphastart":1,"modwavealphaend":1,"warpanimspeed":0.803,"warpscale":1.22,"zoomexp":1.50374,"warp":0.31218,"wave_y":0.04,"ob_size":0,"ob_a":1,"ib_size":0,"ib_r":1,"ib_g":0,"ib_b":0.75,"ib_a":1,"mv_x":64,"mv_y":48,"mv_l":0,"mv_b":0,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{"sides":41,"additive":1,"num_inst":50,"rad":0.01,"ang":3.20442,"tex_zoom":6.23873,"g":1,"b":1,"a":0,"r2":1,"b2":1,"border_a":1,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"index = instance*q32;\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\n\nang = gmegabuf(index+9);\nrad = gmegabuf(index+4)*2;\n\nr = gmegabuf(index+5);\ng = gmegabuf(index+6);\nb = gmegabuf(index+7);\n\nr2 = r; g2 = g; b2 = b;\n\n\nx = 0.5 + (x-0.5)/q2;"},{"baseVals":{"sides":23,"additive":1,"num_inst":50,"x":0.74,"y":0.27,"rad":0.01,"tex_zoom":0.81948,"g":1,"b":1,"g2":0,"border_a":0,"enabled":0},"init_eqs_eel":"vx = 0","frame_eqs_eel":"sample = instance/(num_inst-1);\n\nx1 = 0.5;\ny1 = 0.5 + (q3-0.5)*0.01;\ny2 = 0.5;\nx = x1 + (sample-0.5)*0.2;\ny = y2*sample + y1*(1-sample);"},{"baseVals":{"sides":100,"additive":1,"rad":0.0999,"tex_zoom":0.73458,"r":0,"g":1,"a":0,"border_a":1,"enabled":0},"init_eqs_eel":"vx = 0","frame_eqs_eel":""},{"baseVals":{"enabled":1,"sides":3,"additive":1,"num_inst":400,"rad":0.16283,"tex_zoom":0.73458,"g":1,"b":1,"g2":0,"border_a":0},"init_eqs_eel":"i3 = 0;\ni4 = 0;","frame_eqs_eel":"i3 = if(equal(instance,0),0,i3);\ni4 = if(equal(instance,0),0,i4);\nppo = 8;\nindex = i4*q32;\nsample = i3 % ppo;\n\nsize = gmegabuf(index+4)*40;\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\n\nang = gmegabuf(index+9);\nrad = size*0.05;\n\nr = gmegabuf(index+5);\ng = gmegabuf(index+6);\nb = gmegabuf(index+7);\n\n\nsample = sample/ppo;\nbending = gmegabuf(index + 12)*5 + gmegabuf(index + 10)*5;\ndir = -ang + (sample-0.4)*bending;\n\n ang =  asin(1)*1.5 - dir + bending*0.05;\n\nx = x + ((sample-0.3)*0.06*cos(dir)*size + sin(dir)*size*bending*0.01);\ny = y + ((sample-0.3)*0.06*sin(dir)*size - cos(dir)*size*bending*0.01);\n\nx = 0.5 + (x-0.5)/q2;\n\nrad = rad*1.5 - sample*0.05*size;\n\ni3 = i3 + 1;\ni4 = if( equal(i3%ppo,0), i4 +1, i4);"}],"waves":[{"baseVals":{"samples":452,"additive":1,"scaling":2.44415,"smoothing":0,"a":0.15,"enabled":0},"init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_eel":"t1 = 0;\nt2 = 0;","point_eqs_eel":"ppo = 9;\nindex = t2*q32;\nsample = t1 % ppo;\n\nnindex = gmegabuf(index + q30); // the next neighbor's index\nnnindex = gmegabuf(index + q30+1); // the next neighbor's index\nnnnindex = gmegabuf(index + q30+2); // the next neighbor's index\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\nr = 0.5 + gmegabuf(index+5)*0.5;\ng = 0.5 + gmegabuf(index+6)*0.5;\nb = 0.5 + gmegabuf(index+7)*0.5;\n\nnx = gmegabuf(nindex);\nny = gmegabuf(nindex+1);\nnnx = gmegabuf(nnindex);\nnny = gmegabuf(nnindex+1);\nnnnx = gmegabuf(nnnindex);\nnnny = gmegabuf(nnnindex+1);\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q2;\nnx = 0.5 + (nx-0.5)/q2;\nny = 0.5 + (ny-0.5)/q2;\nnnx = 0.5 + (nnx-0.5)/q2;\nnny = 0.5 + (nny-0.5)/q2;\nnnnx = 0.5 + (nnnx-0.5)/q2;\nnnny = 0.5 + (nnny-0.5)/q2;\n\nx = if( equal(sample,2), nx, x);\ny = if( equal(sample,2), ny, y);\nx = if( equal(sample,4), nnx, x);\ny = if( equal(sample,4), nny, y);\nx = if( equal(sample,6), nnnx, x);\ny = if( equal(sample,6), nnny, y);\n\na = above(sample,1)*below(sample,ppo-1)*a;\n\nt1 = t1 + 1;\nt2 = if( equal(t1%ppo,0), t2 +1, t2);"},{"baseVals":{"scaling":7.7518,"smoothing":0,"a":0.21,"enabled":0},"init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_eel":"t8 = 1;\n\nt1 = 0.5;\nt2 = 0.9;","point_eqs_eel":"d = d*0.85 + (value1)*1;\n\nx = 0.5 + d*sample*(1-sample);\ny = 0.9 - sample*0.8;"},{"baseVals":{"samples":280,"additive":1,"scaling":5.92556,"smoothing":0,"a":0.5,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"t1 = 0;\nt2 = 0;\n\n","point_eqs_eel":"// q32 number of attributes\n// q31 number of objects\n\nppo = 7; // number of points used for each object\nindex = t2*q32; // object's index\n\nx = 0.5 +(gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\n\n// collecting pairs of index and distance to the current object in a local buffer\ni = 0;\nj = 0;\nloop(q31,\n     d = sqrt( sqr(gmegabuf(index)-gmegabuf(i)) + sqr(gmegabuf(index+1)-gmegabuf(i+1)));\n     d = if( equal(d,0), 1, d);\n     megabuf(j)   = i; // store index/distance pairs\n     megabuf(j+1) = d;\n     j = j+2;\n     i = i+q32;\n    );\n\n// sort that buffer, but only 5 cycles for the 5 nearest objects\ni = 0;\nloop( 5,\n      j = i;\n      smallestfind = 100;\n      findindex = 0;\n      loop( q31-j,\n            distance =megabuf(j*2+1);\n            smaller = above( smallestfind, distance);\n            smallestfind = if(smaller, distance, smallestfind);\n            findindex = if( smaller, j*2, findindex);\n            j = j + 1;\n          );\n\n      // now that the nearest object was found, swap it to the buffer's top\n\n      j = megabuf(i);\n      d = megabuf(i+1);\n\n      megabuf(i)   = megabuf(findindex);\n      megabuf(i+1) = megabuf(findindex+1);\n      megabuf(findindex)   = j;\n      megabuf(findindex+1) = d;\n\n      i = i+1;\n    );\n\n\nindex2 = (t1)%ppo;\ni = megabuf(index2-2);\nxx = 0.5 + (gmegabuf(i)-0.5)/q2;\nyy = 0.5 + (gmegabuf(i+1)-0.5)/q2;\nw = asin(1)*index2/4;\n//xx = x + sin(w)*0.1;\n//yy = y + cos(w)*0.1;\nx = if( equal(index2%2,0), x, xx);\ny = if( equal(index2%2,0), y, yy);\n\n\na = below(index2,ppo-1)*above(index2,1)*a;\nr = 0.5 + gmegabuf(index + 5)*0.5;\ng = 0.5 + gmegabuf(index + 6)*0.5;\nb = 0.5 + gmegabuf(index + 7)*0.5;\n\n\nt2 = t2 + equal(t1%ppo,ppo-1);\nt1 = t1 + 1;\n\n//a = above(t1,128);"},{"baseVals":{"samples":15,"thick":1,"additive":1,"scaling":5.92556,"smoothing":0,"a":0.4,"enabled":0},"init_eqs_eel":"t2 = 0","frame_eqs_eel":"t1 = 0;\nt2 = 0;\nt3 = 0;\nt4 = 0.5;","point_eqs_eel":"ppo = 5;\n\nindex = t2*q32;\nneighbor = 1;\nneighbor = gmegabuf(index+10+neighbor);\nx = 0.5 + (gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\nxx = 0.5 + ( gmegabuf(neighbor) - 0.5)/q2;\nyy = 0.5 + ( gmegabuf(neighbor+1) - 0.5)/q2;\n\nx = if( equal(t1 % 2, 0), x, xx);\ny = if( equal(t1 % 2, 0), y, yx);\n\n\nt2 = t2 + equal(t1,ppo);\nt1 = if(above(t1,ppo),t1-ppo,t1) + 1;\n"}],"init_eqs_eel":"// clear buffer\ni = 0; loop(1024*1024, gmegabuf(i) = 0; i = i+1;);\n\ncount = 50;\nattributes = 32;\nnListStart = 24; // starting index of neighbor list\n\nminradius = 0.01;\nmaxradius = 0.0333;\nv = 0.0;\n\n// randomize initial coordinates\nindex = 0;\nloop(count,\n     gmegabuf(index*attributes) = rand(1000)/1000;\n     gmegabuf(index*attributes+1) = rand(1000)/1000;\n     gmegabuf(index*attributes+2) = v*(rand(1000)/1000-0.5);\n     gmegabuf(index*attributes+3) = v*(rand(1000)/1000-0.5);\n     gmegabuf(index*attributes+4) = minradius + (maxradius-minradius)*(index+1)/count;\n     gmegabuf(index*attributes+5) = rand(1000)/1000;\n     gmegabuf(index*attributes+6) = rand(1000)/1000;\n     gmegabuf(index*attributes+7) = rand(1000)/1000;\n     gmegabuf(index*attributes+8) = pow(gmegabuf(index*attributes+4),3) ;\n     gmegabuf(index*attributes+9) = 4*asin(1)*rand(1000)/1000;\n     gmegabuf(index*attributes+10) = 0;\n     gmegabuf(index*attributes+13) = index/count;\n     index = index+1;\n    );\n\nq30 = nListStart;\nq31 = count;\nq32 = attributes;\n\n// 0, x\n// 1, y\n// 2, vx\n// 3, vy\n// 4, radius\n// 5, red\n// 6, green\n// 7, blue\n// 8, mass\n// 9, angle\n// 10, rotation\n// 11, bend force\n// 12, bending\n// 13, sample","frame_eqs_eel":"random = rand(1000)/1000;\n\ndt = 1/fps;\nbend_force = bend_force*0.92 - 4*bend*dt + 2*(random-0.5)*dt;\n\nbend = bend + 60*bend_force*dt;\nq3 = bend*4;\n\nmonitor = bend;\n\nwarp = 0;\nzoom = 1;\n\ngravity = 0.0015*dt*0;\ndampening = 0.;\nfriction = 2048*dt;\nshock = 0.002;\npi2 = asin(1);\n\nnn = 3; // number of nearest neighbors to search, reduce if not needed\n        // provide enough attributes, otherwise the next object's coordinate will be overwritten\n        // collision detection is based on nearest neighbors, so keep it at least at 1.\n\ncheck = 2; // how many neighbors will be checked for a possible collision. may not be above nn.\n           // raise to avoid odd behavior in clusters of touching objects.\n\nbouncefactor = 0.1;\nrotatefactor = 0.0; // relation between angular and translative momentum, when object hits a border. this is an empirical value for a convincing impression\n\n\n\nh = (aspecty-1)*0.5; w = (aspectx-1)*0.5;\nindex = 0; index2 = 0;\nloop(count,\n\n     random = rand(1000)/1000;\n     sample = gmegabuf(index+13);\n\n     // bend force\n     gmegabuf(index + 11) = gmegabuf(index + 11)*0.92 - 4*gmegabuf(index+12)*dt + 2*(random-0.5)*dt*(bass*0.4*sample + treb*0.5*(1-sample));\n\n     // bend\n     gmegabuf(index + 12) += 60*gmegabuf(index + 11)*dt;\n\n     v = sqrt( sqr( gmegabuf(index + 2) ) + sqr( gmegabuf(index + 3) ) );\n\n     // apply friction\n     fric = max(0,1 - sqr(v*friction) - v*2);\n     gmegabuf(index + 2) *= fric;\n     gmegabuf(index + 3) *= fric;\n\n     // apply direction change\n     gmegabuf(index + 10) = gmegabuf(index + 10)*fric +  v*gmegabuf(index +12)*0;\n\n     // apply acceleration force\n     acceleration = random*0.000 + abs(gmegabuf(index+11))*0.003;\n     direction = gmegabuf(index + 9) - pi2;\n     gmegabuf(index + 2) += sin(direction)*acceleration;\n     gmegabuf(index + 3) += cos(direction)*acceleration;\n\n     // adding velocity vectors\n     gmegabuf(index) = gmegabuf(index) + gmegabuf(index+2)*60*dt;\n     gmegabuf(index+1) = gmegabuf(index+1) + gmegabuf(index+3)*60*dt;\n     gmegabuf(index+9) = gmegabuf(index+9) + gmegabuf(index+10)*0.5;\n\n     // applying gravity\n     gmegabuf(index+3) = gmegabuf(index+3) - gravity;\n\n     vr = sin(gmegabuf(index+10))*gmegabuf(index+4); // rotation speed at the surface\n\n     // bounce off ceiling\n     bounce = above( gmegabuf(index+1), 1 - gmegabuf(index+4) + w);\n     gmegabuf(index+2) = if( bounce, gmegabuf(index+2) + (vr+gmegabuf(index+2))*rotatefactor, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, -abs(gmegabuf(index+3))*dampening - shock, gmegabuf(index+3));\n     vr = if( bounce, vr - (gmegabuf(index+2) + vr)*(1-rotatefactor), vr);\n\n     // bounce off floor\n     bounce = below( gmegabuf(index+1), gmegabuf(index+4) - w);\n     gmegabuf(index+2) = if( bounce, gmegabuf(index+2) + (vr-gmegabuf(index+2))*rotatefactor, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, abs(gmegabuf(index+3))*dampening + shock, gmegabuf(index+3));\n     vr = if( bounce, vr + (gmegabuf(index+2) - vr)*(1-rotatefactor), vr);\n\n     // bounce off right border\n     bounce = above( gmegabuf(index), 1 - gmegabuf(index+4) + h);\n     gmegabuf(index+2) = if( bounce, -abs(gmegabuf(index+2))*dampening - shock, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, gmegabuf(index+3) + (vr-gmegabuf(index+3))*rotatefactor, gmegabuf(index+3));\n     vr = if( bounce, vr + (gmegabuf(index+3) - vr)*(1-rotatefactor), vr);\n\n     // bounce off left border\n     bounce = below( gmegabuf(index), gmegabuf(index+4) - h);\n     gmegabuf(index+2) = if( bounce, abs(gmegabuf(index+2))*dampening + shock, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, gmegabuf(index+3) - (vr+gmegabuf(index+3))*rotatefactor, gmegabuf(index+3));\n     vr = if( bounce, vr - (gmegabuf(index+3) + vr)*(1-rotatefactor), vr);\n\n     gmegabuf(index+10) = asin(vr/gmegabuf(index+4));\n\n     i = 0; j = 0; // collecting pairs of index and distance to the current object in a local buffer\n     loop( count,\n           d = sqrt( sqr(gmegabuf(index)-gmegabuf(i)) + sqr(gmegabuf(index+1)-gmegabuf(i+1)));\n           d = if( equal(d,0), 10, d); // leave out comparison with itself (where d == 0, set d to a high value)\n           d = d - (gmegabuf(index+4)+gmegabuf(i+4))*0.5; // subtract radius (surface to surface distance)\n           megabuf(j)   = i; // store index/distance pairs\n           megabuf(j+1) = d;\n           j = j+2;\n           i = i+attributes; );\n     i = 0; // sort that buffer, but only as many cycles as needed for the _nn_ nearest neighbors\n     loop( nn,\n           j = i; smallestfind = 10; findindex = -1;\n           loop( count-j,\n                 distance =megabuf(j*2+1);\n                 smaller = above( smallestfind, distance);\n                 smallestfind = if(smaller, distance, smallestfind);\n                 findindex = if( smaller, j*2, findindex);\n                 j = j + 1; );\n           j = megabuf(i*2); d = megabuf(i*2+1);\n           megabuf(i*2)   = megabuf(findindex);\n           megabuf(i*2+1) = megabuf(findindex+1);\n           megabuf(findindex)   = j;\n           megabuf(findindex+1) = d;\n           i = i+1;\n         );\n     i = 0; // storing the indexes of the nearest neighbors in the list\n     loop( nn,\n           gmegabuf(index + nListStart + i) = megabuf(i*2);\n           i = i +1;\n         );\n     i = 0; // collision detection and impulse transmission below\n     loop( check,\n           index2 = megabuf(i);\n           hit = below( sqrt( sqr( gmegabuf(index) - gmegabuf(index2)) +\n                              sqr( gmegabuf(index+1) - gmegabuf(index2+1))),\n                        gmegabuf(index + 4) + gmegabuf(index2 + 4)\n                      )\n                 *\n                 above( sqrt( sqr( gmegabuf(index)   - gmegabuf(index2))+\n                        sqr( gmegabuf(index+1) - gmegabuf(index2+1))),\n                        sqrt( sqr( gmegabuf(index+0) - gmegabuf(index2+0)+\n                                   gmegabuf(index+2) - gmegabuf(index2+2))+\n                              sqr( gmegabuf(index+1) - gmegabuf(index2+1)+\n                                   gmegabuf(index+3) - gmegabuf(index2+3)) ) );\n           ref_ang = atan2( gmegabuf(index2)-gmegabuf(index), // calculating the angle of the common tangent\n                            gmegabuf(index2 + 1)-gmegabuf(index + 1)) + pi2;\n           v1 = sqrt(sqr( gmegabuf(index + 2)) + sqr( gmegabuf(index + 3))); // velocity of object1\n           v2 = sqrt(sqr( gmegabuf(index2 + 2)) + sqr( gmegabuf(index2 + 3)));  // velocity of object2\n           w1 = atan2( gmegabuf(index + 2), gmegabuf(index + 3));   // object1 motion angle\n           w2 = atan2( gmegabuf(index2 + 2), gmegabuf(index2 + 3)); // object2 motion angle\n           vr2 = sin(gmegabuf(index2 + 10))*gmegabuf(index2+4); // the other object's surface velocity\n           m1 = gmegabuf(index + 8); m2 = gmegabuf(index2 + 8);\n           vv1 = ((m1-m2)*v1 + 2*m2*v2)/(m1+m2); vv2 = ((m2-m1)*v2 + 2*m1*v1)/(m1+m2);\n           vrr = ((m1-m2)*vr + 2*m2*vr2)/(m1+m2); vrr2 = ((m2-m1)*vr2 + 2*m1*vr)/(m1+m2);\n\n           gmegabuf( index + 2) = if( hit, sin(ref_ang)*v1*cos(w1-ref_ang) + ((vr-vr2)-sin(ref_ang)*v1*cos(w1-ref_ang))*rotatefactor\n                                         + cos(ref_ang)*vv1*sin(w2-ref_ang),\n                                                  gmegabuf( index + 2) );\n\n           gmegabuf( index + 3) = if( hit, cos(ref_ang)*v1*cos(w1-ref_ang) + ((vr-vr2)-cos(ref_ang)*v1*cos(w1-ref_ang))*rotatefactor\n                                         - sin(ref_ang)*vv1*sin(w2-ref_ang),\n                                                 gmegabuf( index + 3) );\n\n           gmegabuf( index2 + 2) = if( hit, sin(ref_ang)*v2*cos(w2-ref_ang) + ((vr2-vr)-sin(ref_ang)*v2*cos(w2-ref_ang))*rotatefactor\n                                          + cos(ref_ang)*vv2*sin(w1-ref_ang),\n                                                  gmegabuf( index2 + 2) );\n\n           gmegabuf( index2 + 3) = if( hit, cos(ref_ang)*v2*cos(w2-ref_ang) + ((vr2-vr)-cos(ref_ang)*v2*cos(w2-ref_ang))*rotatefactor\n                                          - sin(ref_ang)*vv2*sin(w1-ref_ang),\n                                                  gmegabuf( index2 + 3) );\n\n           vr = if( hit, vrr + (cos(w1-ref_ang)*(v1-v2)-vrr)*(1-rotatefactor) , vr);\n           gmegabuf( index + 10) = asin( vr / gmegabuf(index+4) );\n\n           vr2 = if( hit, vrr2 + (cos(w2-ref_ang)*(v2-v1)-vrr2)*(1-rotatefactor) , vr2);\n           gmegabuf( index2 + 10) = asin( vr2 / gmegabuf(index2+4) );\n\n           i=i+2;\n         );\n     index = index+attributes;\n    );\n\n\nq1 = aspectx;\nq2 = aspecty;","pixel_eqs_eel":"","warp":"vec2 pix;\nfloat xlat_mutablebuf2;\n shader_body { \n  pix = (texsize.zw * 2.0);\n  vec3 res_1;\n  res_1 = (texture (sampler_main, (uv + (pix * vec2(1.0, 0.0)))).xyz - 0.5);\n  res_1 = ((res_1 * res_1) * sign(res_1));\n  vec3 res_2;\n  res_2 = (texture (sampler_main, (uv + (pix * vec2(0.0, 1.0)))).xyz - 0.5);\n  res_2 = ((res_2 * res_2) * sign(res_2));\n  vec3 res_3;\n  res_3 = (texture (sampler_main, (uv + (pix * vec2(-1.0, 0.0)))).xyz - 0.5);\n  res_3 = ((res_3 * res_3) * sign(res_3));\n  vec3 res_4;\n  res_4 = (texture (sampler_main, (uv + (pix * vec2(0.0, -1.0)))).xyz - 0.5);\n  res_4 = ((res_4 * res_4) * sign(res_4));\n  vec3 res_5;\n  res_5 = (texture (sampler_main, (uv + (pix * vec2(2.0, 0.0)))).xyz - 0.5);\n  res_5 = ((res_5 * res_5) * sign(res_5));\n  vec3 res_6;\n  res_6 = (texture (sampler_main, (uv + (pix * vec2(0.0, 2.0)))).xyz - 0.5);\n  res_6 = ((res_6 * res_6) * sign(res_6));\n  vec3 res_7;\n  res_7 = (texture (sampler_main, (uv + (pix * vec2(-2.0, 0.0)))).xyz - 0.5);\n  res_7 = ((res_7 * res_7) * sign(res_7));\n  vec3 res_8;\n  res_8 = (texture (sampler_main, (uv + (pix * vec2(0.0, -2.0)))).xyz - 0.5);\n  res_8 = ((res_8 * res_8) * sign(res_8));\n  vec3 res_9;\n  res_9 = (texture (sampler_main, uv).xyz - 0.5);\n  res_9 = ((res_9 * res_9) * sign(res_9));\n  xlat_mutablebuf2 = (((\n    ((((\n      (res_1.y + res_2.y)\n     + \n      (res_3.y + res_4.y)\n    ) + (res_5.y / 2.0)) + (res_6.y / 2.0)) + (res_7.y / 2.0))\n   + \n    (res_8.y / 2.0)\n  ) / 3.0) - res_9.x);\n  xlat_mutablebuf2 = (xlat_mutablebuf2 * 0.98);\n  vec3 tmpvar_10;\n  tmpvar_10.z = 0.0;\n  tmpvar_10.x = texture (sampler_pw_main, uv).y;\n  tmpvar_10.y = ((sign(xlat_mutablebuf2) * sqrt(\n    abs(xlat_mutablebuf2)\n  )) + 0.5);\n  vec4 tmpvar_11;\n  tmpvar_11.w = 1.0;\n  tmpvar_11.xyz = tmpvar_10;\n  ret = tmpvar_11.xyz;\n }","comp":"uniform sampler2D sampler_smalltiled_lizard_scales;\nvec2 pix;\nvec2 xlat_mutabledz;\nvec2 xlat_mutabledz1;\nvec2 xlat_mutableuv1;\n shader_body { \n  pix = (texsize.zw * 2.0);\n  vec2 uv_1;\n  vec2 uvi_2;\n  uvi_2 = (uv + (pix * vec2(1.0, 0.0)));\n  float res_3;\n  res_3 = (mix ((\n    (texture (sampler_blur1, uvi_2).xyz * scale1)\n   + bias1).x, (\n    (texture (sampler_blur1, uvi_2).xyz * scale1)\n   + bias1).y, 0.5) - 0.5);\n  res_3 = ((res_3 * res_3) * sign(res_3));\n  vec2 uvi_4;\n  uvi_4 = (uv + (pix * vec2(-1.0, 0.0)));\n  float res_5;\n  res_5 = (mix ((\n    (texture (sampler_blur1, uvi_4).xyz * scale1)\n   + bias1).x, (\n    (texture (sampler_blur1, uvi_4).xyz * scale1)\n   + bias1).y, 0.5) - 0.5);\n  res_5 = ((res_5 * res_5) * sign(res_5));\n  xlat_mutabledz1.x = (res_3 - res_5);\n  vec2 uvi_6;\n  uvi_6 = (uv + (pix * vec2(0.0, 1.0)));\n  float res_7;\n  res_7 = (mix ((\n    (texture (sampler_blur1, uvi_6).xyz * scale1)\n   + bias1).x, (\n    (texture (sampler_blur1, uvi_6).xyz * scale1)\n   + bias1).y, 0.5) - 0.5);\n  res_7 = ((res_7 * res_7) * sign(res_7));\n  vec2 uvi_8;\n  uvi_8 = (uv + (pix * vec2(0.0, -1.0)));\n  float res_9;\n  res_9 = (mix ((\n    (texture (sampler_blur1, uvi_8).xyz * scale1)\n   + bias1).x, (\n    (texture (sampler_blur1, uvi_8).xyz * scale1)\n   + bias1).y, 0.5) - 0.5);\n  res_9 = ((res_9 * res_9) * sign(res_9));\n  xlat_mutabledz1.y = (res_7 - res_9);\n  float res_10;\n  vec4 tmpvar_11;\n  tmpvar_11 = texture (sampler_blur1, uv);\n  res_10 = (mix ((\n    (tmpvar_11.xyz * scale1)\n   + bias1).x, (\n    (tmpvar_11.xyz * scale1)\n   + bias1).y, 0.5) - 0.5);\n  res_10 = ((res_10 * res_10) * sign(res_10));\n  uv_1 = (uv + ((xlat_mutabledz1 * \n    clamp ((1.0 - res_10), 0.0, 1.0)\n  ) * 0.5));\n  xlat_mutabledz.x = (texture (sampler_main, (uv_1 + (pix * vec2(1.0, 0.0)))).z - texture (sampler_main, (uv_1 + (pix * vec2(-1.0, 0.0)))).z);\n  xlat_mutabledz.y = (texture (sampler_main, (uv_1 + (pix * vec2(0.0, 1.0)))).z - texture (sampler_main, (uv_1 + (pix * vec2(0.0, -1.0)))).z);\n  xlat_mutableuv1 = ((uv_1 - 0.1) + (xlat_mutabledz1 * 8.0));\n  vec2 x_12;\n  x_12 = (xlat_mutableuv1 + (xlat_mutabledz * 0.6));\n  vec2 x_13;\n  x_13 = (xlat_mutableuv1 + xlat_mutabledz);\n  vec2 x_14;\n  x_14 = (xlat_mutableuv1 + (xlat_mutabledz * 2.6));\n  vec3 tmpvar_15;\n  tmpvar_15.x = sqrt(dot (x_12, x_12));\n  tmpvar_15.y = sqrt(dot (x_13, x_13));\n  tmpvar_15.z = sqrt(dot (x_14, x_14));\n  vec4 tmpvar_16;\n  tmpvar_16.w = 1.0;\n  tmpvar_16.xyz = ((texture (sampler_smalltiled_lizard_scales, (\n    (uv_1 + xlat_mutabledz1)\n   - \n    (time * 0.02)\n  )) * 0.5).xyz + ((\n    (0.1 / tmpvar_15)\n   - \n    (texture (sampler_main, uv).z * 0.2)\n  ) - (texture (sampler_main, \n    (0.8 - uv_1)\n  ).z * 0.2)));\n  ret = tmpvar_16.xyz;\n }"}