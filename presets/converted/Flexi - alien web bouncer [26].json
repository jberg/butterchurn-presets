{"version":2,"baseVals":{"rating":4,"gammaadj":1,"decay":0.995,"echo_zoom":1.007,"echo_orient":3,"additivewave":1,"modwavealphabyvolume":1,"wave_brighten":0,"wrap":0,"wave_a":1.413,"wave_scale":0.418,"wave_smoothing":0,"wave_mystery":-0.66,"modwavealphastart":2,"modwavealphaend":2,"warpanimspeed":0.568,"warpscale":1.867,"zoomexp":1.00001,"zoom":0.99951,"warp":0.1089,"wave_r":0,"wave_g":0,"wave_x":0.24,"wave_y":0.44,"ob_size":0,"ob_a":1,"ib_size":0,"ib_r":0,"ib_b":1,"ib_a":1,"mv_x":64,"mv_y":48,"mv_l":0,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{"sides":100,"additive":1,"thickoutline":1,"rad":0.0277,"ang":6.03186,"tex_ang":6.03186,"tex_zoom":0.6839,"a":0,"r2":1,"g2":0,"border_r":0.05,"border_a":1,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"an = an + q6;\nang = an*0.5;\nx = q4;\ny = q5;\nrad = q3;\n\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q1;\n"},{"baseVals":{"sides":100,"additive":1,"thickoutline":1,"rad":0.0277,"ang":6.03186,"tex_ang":6.03186,"tex_zoom":0.6839,"a":0,"r2":1,"g2":0,"border_r":0.05,"border_a":1,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"an = an + q9;\nang = an*0.5;\nx = q7;\ny = q8;\nrad = q3;\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q1;\n"},{"baseVals":{"sides":100,"additive":1,"thickoutline":1,"rad":0.0277,"ang":6.03186,"tex_ang":6.03186,"tex_zoom":0.6839,"a":0,"r2":1,"g2":0,"border_r":0.05,"border_a":1,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"an = an + q12;\nang = an*0.5;\nx = q10;\ny = q11;\nrad = q3;\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q1;\n"},{"baseVals":{"sides":48,"additive":1,"num_inst":4,"rad":0.0277,"ang":6.03186,"tex_ang":6.03186,"tex_zoom":0.6839,"g":1,"b":1,"r2":1,"b2":1,"a2":1,"border_r":0,"border_g":0,"border_b":0,"border_a":1,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"an = an + 0.5*q16/num_inst;\nw = asin(1)*4*instance/num_inst + an;\nx = q6 + sin(w)*q5*0.5;\ny = q7 + cos(w)*q5*0.5;\nrad = q5*0.25;\n\n\n//x = 0.5 + (x-0.5)/q2;\n//y = 0.5 + (y-0.5)/q1;\n"}],"waves":[{"baseVals":{"enabled":1,"thick":1,"additive":1,"scaling":2.0231,"smoothing":0,"r":0.18},"init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_eel":"vol = bass*8 + mid*5 + treb*3;\nm = m*0.97 + vol*0.08;\nmonitor = vol;\nbeat = above(vol,res)*above(vol,m)*above(vol,16);\ndiff = (1-beat)*diff + beat*(vol-res);\nres = beat*(vol + m*0.04) + (1-beat)*(res -  (0.1+diff*0.02)*60/fps);\nres = max(0,res);\n\na = beat;","point_eqs_eel":"tt3 = tt3*0.6 + (value1)*1;\ntt2 = tt2*0.7 + tt3*0.2;\ntt1 = tt1*0.8 + tt2*0.1;\nd = d*0.9 + tt1*0.2;\n\ny = 0.5 + d*sample*(1-sample)*2;\nx =  -0.05 + sample*1.1;"},{"baseVals":{"enabled":1,"spectrum":1,"scaling":0.36971,"smoothing":0,"r":0.01},"init_eqs_eel":"chance = 0;","frame_eqs_eel":"t1 = asin(1);\n\nrot = rot + q6;\nt2 = rot;\n\nq4 = 0.5 + (q4-0.5)*q15;\nq5 = 0.5 + (q5-0.5)*q15;","point_eqs_eel":"w = 4*t1*sample + t2;\nd = q3*0.5*q15 + value1;\n\nx = q4 + sin(w)*d;\ny = q5 + cos(w)*d;"},{"baseVals":{"enabled":1,"spectrum":1,"scaling":0.36971,"smoothing":0,"r":0.01},"init_eqs_eel":"chance = 0;","frame_eqs_eel":"t1 = asin(1);\n\nrot = rot + q9;\nt2 = rot;\n\nq7 = 0.5 + (q7-0.5)*q15;\nq8 = 0.5 + (q8-0.5)*q15;","point_eqs_eel":"w = 4*t1*sample + t2;\nd = q3*0.5*q15 + value1;\n\nx = q7 + sin(w)*d;\ny = q8 + cos(w)*d;"},{"baseVals":{"enabled":1,"spectrum":1,"scaling":0.36971,"smoothing":0,"r":0.01},"init_eqs_eel":"chance = 0;","frame_eqs_eel":"t1 = asin(1);\n\nrot = rot + q12;\nt2 = rot;\n\nq10 = 0.5 + (q10-0.5)*q15;\nq11= 0.5 + (q11-0.5)*q15;","point_eqs_eel":"w = 4*t1*sample + t2;\nd = q3*0.5*q15 + value1;\n\nx = q10 + sin(w)*d;\ny = q11 + cos(w)*d;"}],"init_eqs_eel":"x1 = 0.5;\ny1 = 0.6;\n\nx2 = 0.5;\ny2 = 0.4;\n\nx3 = 0.5;\ny3 = 0.2;\n\nvr1 = 0.0001;\nvr2 = 0.0;\nvr3 = 0.0;\n\nvx1 = 0;\nvx2 = 0;\nvx3 = 0;","frame_eqs_eel":"zoom = 1;\nwave_a = 0;\n\n// impuls transmission with an angular momentum factor, 3 bodies\n// code by Flexi\n// good luck with tuning these values to a fine dynamic behavior ;-)\n\n   r = 0.11+ (bass_att+treb_att)*0.005; // the object's radius\n\n   gravity = 0.01;\n\n   bouncedampening = 0.94;  // This is where kinetic energy is taken from the system.\n                            // Be careful with values close to 1.0\n\n   bounceimpact = 0.17;     // When an object hits one border, it slightly penetrates it.\n                            // The impact value determines how strong this depth is taken as resulting impuls.\n                            // This is where kinetic energy possibly is added to the system depent on the increase in size.\n\n// don't change below\n\n// bouncing off borders (the first rotating object)\n\n   y1  = y1+vy1; // adding velocity vector to position\n   x1  = x1+vx1;\n\n   vr  = sin(vr1)*r; // tangential velocity\nbounce = below(y1,r-(aspectx-1)*0.5); // hit floor?\n   vy1 = if(bounce, abs(vy1)*bouncedampening + (r-y1-(aspectx-1)*0.5)*bounceimpact, vy1-gravity/fps);\n   vx1 = if(bounce, vx1 + (vr-vx1)*bounceimpact, vx1);\n   vr  = if(bounce, vr + (vx1-vr)*0.85 , vr);\nbounce = above(x1,1-r+(aspecty-1)*0.5); // hit right border?\n   vx1 = if(bounce, - abs(vx1)*bouncedampening + (1-r-x1+(aspecty-1)*0.5)*bounceimpact, vx1);\n   vy1 = if(bounce, vy1 + (vr-vy1)*bounceimpact, vy1);\n   vr  = if(bounce, vr + (vy1-vr)*0.85 , vr);\nbounce = below(x1,r-(aspecty-1)*0.5); // hit left border?\n   vx1 = if(bounce, abs(vx1)*bouncedampening + (r-x1-(aspecty-1)*0.5)*bounceimpact, vx1);\n   vy1 = if(bounce, vy1 + (-vr-vy1)*bounceimpact, vy1);\n   vr  = if(bounce, vr - (vy1+vr)*0.85 , vr);\n   vr1 = asin(vr/r); // angular velocity of the surface\n\n// bouncing off borders (the second rotating object)\nvr=sin(vr2)*r;bounce=below(y2,r-(aspectx-1)*0.5);y2=y2+vy2;vy2=if(bounce,abs(vy2)*bouncedampening+(r-y2-(aspectx-1)*0.5)\n*bounceimpact,vy2-gravity/fps);vx2=if(bounce,vx2+(vr-vx2)*bounceimpact,vx2);vr=if(bounce,vr+(vx2-vr)*0.85,vr);\nbounce=above(x2,1-r+(aspecty-1)*0.5);vx2=if(bounce,-abs(vx2)*bouncedampening+(1-r-x2+(aspecty-1)*0.5)*bounceimpact,vx2);\nvy2=if(bounce,vy2+(vr-vy2)*bounceimpact,vy2);vr=if(bounce,vr+(vy2-vr)*0.85,vr);bounce=below(x2,r-(aspecty-1)*0.5);x2=x2+vx2;\nvx2=if(bounce,abs(vx2)*bouncedampening+(r-x2-(aspecty-1)*0.5)*bounceimpact,vx2);vy2=if(bounce,vy2+(-vr-vy2)*bounceimpact,vy2);\nvr=if(bounce,vr-(vy2+vr)*0.85,vr);vr2=asin(vr/r);\n\n// bouncing off borders (the third rotating object)\nvr=sin(vr3)*r;bounce=below(y3,r-(aspectx-1)*0.5);y3=y3+vy3;vy3=if(bounce,abs(vy3)*bouncedampening+(r-y3-(aspectx-1)*0.5)\n*bounceimpact,vy3-gravity/fps);vx3=if(bounce,vx3+(vr-vx3)*bounceimpact,vx3);vr=if(bounce,vr+(vx3-vr)*0.85,vr);\nbounce=above(x3,1-r+(aspecty-1)*0.5);vx3=if(bounce,-abs(vx3)*bouncedampening+(1-r-x3+(aspecty-1)*0.5)*bounceimpact,vx3);\nvy3=if(bounce,vy3+(vr-vy3)*bounceimpact,vy3);vr=if(bounce,vr+(vy3-vr)*0.85,vr);bounce=below(x3,r-(aspecty-1)*0.5);x3=x3+vx3;\nvx3=if(bounce,abs(vx3)*bouncedampening+(r-x3-(aspecty-1)*0.5)*bounceimpact,vx3);vy3=if(bounce,vy3+(-vr-vy3)*bounceimpact,vy3);\nvr=if(bounce,vr-(vy3+vr)*0.85,vr);vr3=asin(vr/r);\n\n// bouncing of object1 with object2\n\nbounce = below( sqrt( sqr(x1+vx1-x2-vx2) + sqr(y1+vy1-y2-vy2)), 2*r); // is distance < diameter ?\nbounce = bounce*below(sqrt( sqr(x1+vx1-x2-vx2) + sqr(y1+vy1-y2-vy2)),sqrt( sqr(x1-x2) + sqr(y1-y2))); // detect only if objects\n                                                                                                      // move towards each other\nref_ang = atan2(x2-x1,y2-y1)+asin(1); // angle of the common tangent\nv1 = sqrt(vx1*vx1+vy1*vy1); // absolute velocity\nv2 = sqrt(vx2*vx2+vy2*vy2);\nw1 = atan2(vx1,vy1); // absolute motion angle\nw2 = atan2(vx2,vy2);\nvr = sin(vr1)*r; // angular velocity of the surface\nv2r= sin(vr2)*r;\n// in case of a bounce, the velocity is split into the horizontal and vertical part relative to the common tangent,\n// then the vertical aspects get swapped.\n// a bounce goes 90% into impuls transmission and 10% angular momentum transmission.\n// these values make quite a plausible impression, but in fact this has pretty little to do with physical correctness ;)\nvx1 = if(bounce,sin(ref_ang)*v1*cos(w1-ref_ang) + ((vr-v2r)-sin(ref_ang)*v1*cos(w1-ref_ang))*0.1\n              + sin(ref_ang+asin(1))*v2*cos(w2-ref_ang-asin(1)), vx1);\nvy1 = if(bounce,cos(ref_ang)*v1*cos(w1-ref_ang) + ((vr-v2r)-cos(ref_ang)*v1*cos(w1-ref_ang))*0.1\n              + cos(ref_ang+asin(1))*v2*cos(w2-ref_ang-asin(1)), vy1);\nvx2 = if(bounce,sin(ref_ang)*v2*cos(w2-ref_ang) + ((v2r-vr)-sin(ref_ang)*v2*cos(w2-ref_ang))*0.1\n              + sin(ref_ang+asin(1))*v1*cos(w1-ref_ang-asin(1)), vx2);\nvy2 = if(bounce,cos(ref_ang)*v2*cos(w2-ref_ang) + ((v2r-vr)-cos(ref_ang)*v2*cos(w2-ref_ang))*0.1\n              + cos(ref_ang+asin(1))*v1*cos(w1-ref_ang-asin(1)), vy2);\nvr = if(bounce, vr + (cos(w1-ref_ang)*(v1-v2)-vr)*0.9 , vr);\nvr1 = asin(vr/r);\nv2r = if(bounce, v2r + (cos(w2-ref_ang)*(v2-v1)-v2r)*0.9 , v2r);\nvr2 = asin(v2r/r);\n\n// bouncing of object1 with object3\n\n\nbounce=below(sqrt(sqr(x1+vx1-x3-vx3)+sqr(y1+vy1-y3-vy3)),2*r);bounce=bounce*below(sqrt(sqr(x1+vx1-x3-\nvx3)+sqr(y1+vy1-y3-vy3)),sqrt(sqr(x1-x3)+sqr(y1-y3)));ref_ang=atan2(x3-x1,y3-y1)+asin(1);v1=sqrt(vx1*vx1\n+vy1*vy1);v2=sqrt(vx3*vx3+vy3*vy3);w1=atan2(vx1,vy1);w2=atan2(vx3,vy3);vr=sin(vr1)*r;v2r=sin(vr3)*r;vx1\n=if(bounce,sin(ref_ang)*v1*cos(w1-ref_ang)+((vr-v2r)-sin(ref_ang)*v1*cos(w1-ref_ang))*0.1+sin(ref_ang+\nasin(1))*v2*cos(w2-ref_ang-asin(1)),vx1);vy1=if(bounce,cos(ref_ang)*v1*cos(w1-ref_ang)+((vr-v2r)-cos\n(ref_ang)*v1*cos(w1-ref_ang))*0.1+cos(ref_ang+asin(1))*v2*cos(w2-ref_ang-asin(1)),vy1);vx3=if(bounce,sin\n(ref_ang)*v2*cos(w2-ref_ang)+((v2r-vr)-sin(ref_ang)*v2*cos(w2-ref_ang))*0.1+sin(ref_ang+asin(1))*v1*cos\n(w1-ref_ang-asin(1)),vx3);vy3=if(bounce,cos(ref_ang)*v2*cos(w2-ref_ang)+((v2r-vr)-cos(ref_ang)*v2*cos(w2\n-ref_ang))*0.1+cos(ref_ang+asin(1))*v1*cos(w1-ref_ang-asin(1)),vy3);vr=if(bounce,vr+(cos(w1-ref_ang)*(v1\n-v2)-vr)*0.9,vr);vr1=asin(vr/r);v2r=if(bounce,v2r+(cos(w2-ref_ang)*(v2-v1)-v2r)*0.9,v2r);vr3=asin(v2r/r);\n\n// bouncing of object3 with object2\nbounce=below(sqrt(sqr(x3+vx3-x2-vx2)+sqr(y3+vy3-y2-vy2)),2*r);bounce=bounce*below(sqrt(sqr(x2+vx2-x3-\nvx3)+sqr(y2+vy2-y3-vy3)),sqrt(sqr(x2-x3)+sqr(y2-y3)));ref_ang=atan2(x2-x3,y2-y3)+asin(1);v1=sqrt(vx3*vx3\n+vy3*vy3);v2=sqrt(vx2*vx2+vy2*vy2);w1=atan2(vx3,vy3);w2=atan2(vx2,vy2);vr=sin(vr3)*r;v2r=sin(vr2)*r;vx3\n=if(bounce,sin(ref_ang)*v1*cos(w1-ref_ang)+((vr-v2r)-sin(ref_ang)*v1*cos(w1-ref_ang))*0.1+sin(ref_ang+\nasin(1))*v2*cos(w2-ref_ang-asin(1)),vx3);vy3=if(bounce,cos(ref_ang)*v1*cos(w1-ref_ang)+((vr-v2r)-cos\n(ref_ang)*v1*cos(w1-ref_ang))*0.1+cos(ref_ang+asin(1))*v2*cos(w2-ref_ang-asin(1)),vy3);vx2=if(bounce,sin\n(ref_ang)*v2*cos(w2-ref_ang)+((v2r-vr)-sin(ref_ang)*v2*cos(w2-ref_ang))*0.1+sin(ref_ang+asin(1))*v1*cos\n(w1-ref_ang-asin(1)),vx2);vy2=if(bounce,cos(ref_ang)*v2*cos(w2-ref_ang)+((v2r-vr)-cos(ref_ang)*v2*cos(w2\n-ref_ang))*0.1+cos(ref_ang+asin(1))*v1*cos(w1-ref_ang-asin(1)),vy2);vr=if(bounce,vr+(cos(w1-ref_ang)*(v1\n-v2)-vr)*0.9,vr);vr3=asin(vr/r);v2r=if(bounce,v2r+(cos(w2-ref_ang)*(v2-v1)-v2r)*0.9,v2r);vr2=asin(v2r/r);\n\n\nq1 = aspectx;\nq2 = aspecty;\nq3 = r*2;\n\nq4  = x1;  q5 = y1;  q6 = vr1;\nq7  = x2;  q8 = y2;  q9 = vr2;\nq10 = x3; q11 = y3; q12 = vr3;\nq13 = atan2( (x1+x2+x3)/3 - 0.5, (y1+y2+y3)/3-0.5);\nq14 = sigmoid(sqrt( sqr((x1+x2+x3)/3 - 0.5) + sqr((y1+y2+y3)/3-0.5) ),2)*0.2;\nq15 = 1/max(aspectx,aspecty);","pixel_eqs_eel":"c = 42; // impacts the \"sharpness\" of the sigmoid filter function\ns = 0.5; // strength of the rotation\nd = q3*0.6; // radius of the sigmoid filter function\n\n//\ncx1 = 0.5 + (q4-0.5)*q15;\ncy1 = 0.5 - (q5-0.5)*q15;\nd1 = sqrt( sqr(x-cx1) + sqr(y-cy1));\ns1 = sigmoid(d-d1,c)*s;\nrx1 = -q6*sin(y-cy1)*s1;\nry1 = q6*sin(x-cx1)*s1;\n\ncx2 = 0.5 + (q7-0.5)*q15;\ncy2 = 0.5 - (q8-0.5)*q15;\nd2 = sqrt( sqr(x-cx2) + sqr(y-cy2));\ns2 = sigmoid(d-d2,c)*s;\nrx2 = -q9*sin(y-cy2)*s2;\nry2 = q9*sin(x-cx2)*s2;\n\ncx3 = 0.5 + (q10-0.5)*q15;\ncy3 = 0.5 - (q11-0.5)*q15;\nd3 = sqrt( sqr(x-cx3) + sqr(y-cy3));\ns3 = sigmoid(0.12-d3,c)*s;\nrx3 = -q12*sin(y-cy3)*s3;\nry3 = q12*sin(x-cx3)*s3;\n\n\n\ndx = rx1 + rx2 + rx3;\ndy = ry1 + ry2 + ry3;","warp":" shader_body { \n  vec2 my_uv_1;\n  vec3 ret_2;\n  vec3 tmpvar_3;\n  tmpvar_3 = ((640.0 * texsize.z) * ((2.0 * \n    ((texture (sampler_blur2, (uv + vec2(0.01, 0.0))).xyz * scale2) + bias2)\n  ) - (2.0 * \n    ((texture (sampler_blur2, (uv - vec2(0.01, 0.0))).xyz * scale2) + bias2)\n  )));\n  vec3 tmpvar_4;\n  tmpvar_4 = ((512.0 * texsize.w) * ((2.0 * \n    ((texture (sampler_blur2, (uv + vec2(0.0, 0.01))).xyz * scale2) + bias2)\n  ) - (2.0 * \n    ((texture (sampler_blur2, (uv - vec2(0.0, 0.01))).xyz * scale2) + bias2)\n  )));\n  vec2 tmpvar_5;\n  tmpvar_5.x = tmpvar_3.y;\n  tmpvar_5.y = tmpvar_4.y;\n  vec2 tmpvar_6;\n  tmpvar_6.x = tmpvar_3.x;\n  tmpvar_6.y = tmpvar_4.x;\n  vec2 tmpvar_7;\n  tmpvar_7.x = tmpvar_4.y;\n  tmpvar_7.y = -(tmpvar_3.y);\n  vec2 tmpvar_8;\n  tmpvar_8 = (uv - ((\n    ((tmpvar_5 * 0.3) + (tmpvar_6 * 0.1))\n   + \n    (tmpvar_7 * 0.01)\n  ) * 0.01));\n  ret_2.x = texture (sampler_fw_main, (tmpvar_8 - floor(tmpvar_8))).x;\n  ret_2.x = (ret_2.x + ((\n    (2.0 * ret_2.x)\n   - \n    (2.0 * ((texture (sampler_blur1, tmpvar_8).xyz * scale1) + bias1).x)\n  ) * 0.25));\n  vec2 tmpvar_9;\n  tmpvar_9.x = tmpvar_3.y;\n  tmpvar_9.y = tmpvar_4.y;\n  vec2 tmpvar_10;\n  tmpvar_10.x = tmpvar_4.x;\n  tmpvar_10.y = -(tmpvar_3.y);\n  my_uv_1 = ((uv - (tmpvar_9 * 0.01)) + (tmpvar_10 * 0.001));\n  ret_2.y = texture (sampler_fw_main, (my_uv_1 - floor(my_uv_1))).y;\n  ret_2.y = (ret_2.y + ((\n    ((2.0 * ret_2.y) - (2.0 * ((texture (sampler_blur3, my_uv_1).xyz * scale3) + bias3).y))\n   * 0.025) + 0.01));\n  vec4 tmpvar_11;\n  tmpvar_11.w = 1.0;\n  tmpvar_11.xyz = ret_2;\n  ret = tmpvar_11.xyz;\n }","comp":"vec2 xlat_mutabled;\nvec3 xlat_mutabledx;\nvec3 xlat_mutabledy;\n shader_body { \n  vec3 ret_1;\n  xlat_mutabled = (texsize.zw * 1.5);\n  xlat_mutabledx = (texture (sampler_main, (uv_orig + (vec2(1.0, 0.0) * xlat_mutabled))).xyz - texture (sampler_main, (uv_orig - (vec2(1.0, 0.0) * xlat_mutabled))).xyz);\n  xlat_mutabledy = (texture (sampler_main, (uv_orig + (vec2(0.0, 1.0) * xlat_mutabled))).xyz - texture (sampler_main, (uv_orig - (vec2(0.0, 1.0) * xlat_mutabled))).xyz);\n  vec2 tmpvar_2;\n  tmpvar_2.x = xlat_mutabledx.y;\n  tmpvar_2.y = xlat_mutabledy.y;\n  vec2 x_3;\n  x_3 = (tmpvar_2 * 8.0);\n  ret_1 = (((texture (sampler_main, uv).x * \n    (1.0 - sqrt(dot (x_3, x_3)))\n  ) * pow (hue_shader, vec3(6.0, 6.0, 6.0))) * 1.4);\n  vec2 tmpvar_4;\n  tmpvar_4.x = xlat_mutabledx.z;\n  tmpvar_4.y = xlat_mutabledy.z;\n  vec2 x_5;\n  x_5 = (tmpvar_4 * 4.0);\n  vec3 tmpvar_6;\n  tmpvar_6 = mix (ret_1, vec3(1.0, 1.0, 1.0), vec3(sqrt(dot (x_5, x_5))));\n  ret_1 = tmpvar_6;\n  vec4 tmpvar_7;\n  tmpvar_7.w = 1.0;\n  tmpvar_7.xyz = tmpvar_6;\n  ret = tmpvar_7.xyz;\n }"}