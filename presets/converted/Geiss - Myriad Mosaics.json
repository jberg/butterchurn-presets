{"version":2,"baseVals":{"rating":0,"gammaadj":1.9,"echo_zoom":1.169,"wave_mode":7,"wave_thick":1,"wave_a":0.433,"wave_scale":2.62,"wave_smoothing":0.27,"wave_mystery":-0.08,"modwavealphastart":1.03,"modwavealphaend":1.61,"warpanimspeed":1.729,"warpscale":2.108,"zoomexp":1.64463,"zoom":0.99901,"warp":0.45599,"wave_r":0.6,"wave_g":0.8,"ob_g":0.5,"ob_b":0.45,"ob_a":0.26,"mv_a":0},"shapes":[{"baseVals":{"enabled":1,"sides":30,"rad":1.08925,"r":0.8,"g":0.4,"b":0.2,"a":0.05,"border_a":0},"init_eqs_eel":"","frame_eqs_eel":"rad = rad + 0.02*cos(time*3);"},{"baseVals":{"enabled":0},"init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_eel":"q10 = 0;\nmy_rot = 0;\nmy_zoom = 1;\ns = 0.5;","frame_eqs_eel":"wave_r = wave_r + 0.05*sin(0.437*time+1);\nwave_g = wave_g + 0.05*sin(0.544*time+2);\nwave_b = wave_b + 0.05*sin(0.751*time+3);\ndx = dx + 0.003*( 0.60*sin(0.234*time) + 0.40*sin(0.277*time) );\ndy = dy + 0.003*( 0.60*sin(0.284*time) + 0.40*sin(0.247*time) );\ndecay = decay - 0.01*equal(frame%6,0);\ndx = dx + dx_residual;\ndy = dy + dy_residual;\nbass_thresh = above(bass_att,bass_thresh)*2 + (1-above(bass_att,bass_thresh))*((bass_thresh-1.3)*0.96+1.3);\ndx_residual = equal(bass_thresh,2.13)*0.016*sin(time*7) + (1-equal(bass_thresh,2.13))*dx_residual;\ndy_residual = equal(bass_thresh,2.13)*0.012*sin(time*9) + (1-equal(bass_thresh,2.13))*dy_residual;\nwave_x = wave_x - dx_residual*7;\nwave_y = wave_y - dy_residual*7;\nwave_mystery = time*37.03;\n\nnew_rot = rot + 0.013*( 0.60*sin(17.381*time) + 0.40*sin(11.579*time) );\nnew_zoom = zoom + 0.01*( 0.60*sin(20.1934*time+3) + 0.40*sin(16.307*time+9) );\nnew_warp = warp + 0.34*( 0.60*sin(13.5442*time) + 0.40*sin(22.543*time) );\nnew_cx = cx + 0.310*( 0.60*sin(16.374*time) + 0.40*sin(26.294*time) );\nnew_cy = cy + 0.310*( 0.60*sin(18.393*time) + 0.40*sin(37.223*time) );\nnew_s = rand(100)*0.01;\n\n// this is a great way to respond to beats:\n// once you get one, let it decay at a constant rate!!\nrg = max(rg*0.77, 0.02 + 0.5*min(2,max(0,mid_att-1)*1.3));\nq9 = rg;\n\n\n\n// custom wave opacity modulation\n//beat = (bass+mid+treb) / (bass_att+mid_att+treb_att);\nbeat = max(bass/bass_att, mid/mid_att);\nbeat = max(beat, treb/treb_att);\n decay_rate = pow(0.9995, fps);\n beat = max( beat, prev_beat*decay_rate );\n  wave_a = (beat - prev_beat - 0.07)*24;\n  is_beat = above(wave_a, 0.5);\n  rot = (1-is_beat)*my_rot + (is_beat)*new_rot;\n  zoom = (1-is_beat)*my_zoom + (is_beat)*new_zoom;\n  warp = (1-is_beat)*my_warp + (is_beat)*new_warp;\n  cx = (1-is_beat)*my_cx + (is_beat)*new_cx;\n  cy = (1-is_beat)*my_cy + (is_beat)*new_cy;\n  s = (1-is_beat)*my_s + (is_beat)*new_s;\nprev_beat = beat;\nmy_rot = rot;\nmy_zoom = zoom;\nmy_warp = warp;\nmy_cx = cx;\nmy_cy = cy;\nmy_s = s;\n\nq11 = s;","pixel_eqs_eel":"zoom = zoom + cos(ang*7)*0.02;","warp":" shader_body { \n  vec3 ret_1;\n  float tmpvar_2;\n  tmpvar_2 = (0.03 + (1.5 * (q11 * q11)));\n  vec3 tmpvar_3;\n  tmpvar_3.xy = (((\n    (uv_orig * 4.0)\n   * texsize.xy) / 850.0) * tmpvar_2);\n  tmpvar_3.z = (time * 0.055);\n  vec2 tmpvar_4;\n  tmpvar_4 = (uv_orig * texsize.xy);\n  ret_1 = texture (sampler_main, (uv + ((1.53 * \n    (cos(((\n      (0.6 * tmpvar_4)\n     * tmpvar_2) + (texture (sampler_noisevol_hq, tmpvar_3).xy * 9.0))) * texsize.zw)\n  ) / tmpvar_2))).xyz;\n  ret_1 = (ret_1 * 0.99);\n  ret_1 = (ret_1 + (19.52 * (\n    (texture (sampler_noise_lq, ((tmpvar_4 * texsize_noise_lq.zw) + rand_frame.xy)).xyz - 0.5)\n   / 256.0)));\n  ret_1 = mix (ret_1, ret_1.zxy, vec3(0.05, 0.05, 0.05));\n  vec4 tmpvar_5;\n  tmpvar_5.w = 1.0;\n  tmpvar_5.xyz = ret_1;\n  ret = tmpvar_5.xyz;\n }","comp":" shader_body { \n  vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xyz = ((texture (sampler_main, uv).xyz * 1.5) - 0.1);\n  ret = tmpvar_1.xyz;\n }"}