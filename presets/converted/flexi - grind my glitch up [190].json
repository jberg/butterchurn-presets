{"version":2,"baseVals":{"rating":2,"gammaadj":1,"decay":1,"echo_orient":1,"additivewave":1,"modwavealphabyvolume":1,"wave_a":0.009,"wave_scale":2.713,"wave_smoothing":0,"modwavealphastart":1.2,"modwavealphaend":1.2,"warpanimspeed":0.204,"warpscale":8.471,"zoom":0.99951,"warp":0.15038,"wave_r":0.44,"wave_g":0.4,"ob_size":0.005,"ob_r":0.01,"ob_a":1,"ib_size":0.26,"mv_x":44.16,"mv_y":33.6,"mv_l":0.5,"mv_g":0,"mv_b":0,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{"sides":3,"additive":1,"x":0.67,"y":0.53,"rad":0.17457,"ang":0.25133,"tex_ang":3.14159,"tex_zoom":0.99979,"g":1,"b":1,"r2":1,"b2":1,"a2":1,"border_g":0.5,"border_b":0.15,"border_a":0,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"sides":23,"additive":1,"num_inst":817,"rad":0.02798,"tex_ang":3.14159,"tex_zoom":0.99979,"g":1,"b":1,"a":0.41,"r2":1,"b2":1,"border_a":0,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"sides":100,"textured":1,"x":0.9,"g":1,"b":1,"r2":1,"b2":1,"a2":1,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"x = sin(time) * .4 + .5;\n\n\npow( (bass*.15),2);"},{"baseVals":{"sides":36,"additive":1,"rad":0.81623,"r":0,"g":0.04,"g2":0,"border_a":0,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"x = 1-q1;\ny = q2;\nx = 0.5 + (x - 0.5)*0.25;\ny = 0.5 + (y - 0.5)*0.25;"}],"waves":[{"baseVals":{"enabled":1,"sep":4,"spectrum":1,"thick":1,"additive":1,"scaling":100,"smoothing":0,"r":0.05,"g":0.15},"init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\nab = 1;","frame_eqs_eel":"// parameters\nw = time*0.5; // rotation (0..2Pi)\nt1 = 0.5; // center for rotation (x)\nt2 = 0.5; // center for rotation (y)\nt3 = 1; // scale\nt4 = 0; // translation (x)\nt5 = 0; // translation (y)\nt6 = sin(w);\nt7 = cos(w);","point_eqs_eel":"xx = if(equal(sample,0),q3,xx);\nyy = if(equal(sample,0),q4,yy);\n\n\ndx = xx*(1-xx)-q5*xx*yy/(xx+q6);\ndy = q7*yy*(1-yy/xx);\n\nx1 = xx;\ny1 = yy;\n\nxx = xx+dx*0.2;\nyy = yy+dy*0.2;\n\nx1 = 0.5+(x1-0.5)/q1 + dy*value1*0.01;\ny1 = 0.5+(y1-0.5)/q2 - dx*value1*0.01;\n\n\n// synchronized affine transformation\nx = q26 + ((x1-q26)*q32 + (y1-q27)*q31)*q28 + q29;\ny = q27 + (-(x1-q26)*q31 + (y1-q27)*q32)*q28 + q30;"},{"baseVals":{"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"xx1 = if(equal(sample,0),q11,xx1);\nyy1 = if(equal(sample,0),q12,yy1);\nzz1 = if(equal(sample,0),q13,zz1);\n\ndx1 = q14*(yy1-xx1);\ndy1 = xx1*(q15-zz1)-yy1;\ndz1 = xx1*yy1-q16*zz1;\nxx1 = xx1 + q17*dx1;\nyy1 = yy1 + q17*dy1;\nzz1 = zz1 + q17*dz1;\n\nmy_x = xx1*0.02;\nmy_y = yy1*0.02;\nmy_z = zz1*0.02;\n\nx = 0.5 + my_x;\ny = 0.5 + my_y;"},{"baseVals":{"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_eel":"x1 = 0;\ny1= .001;\nz1 = 0;","frame_eqs_eel":"zoom = 1;\nwarp = 0;\nwave_a = 0;\n\n\n// below parameters belong to an extended \"Lotka-Volterra\" model (simple predator-prey differential equation system - see wikipedia)\n\nstartx = 0.7; // initial predator population (used only for the phase plot)\nstarty = 0.7; // initial prey population\n\na = 1.0; // LV-model parameters - some pairs reach a so-called limit-cycle\nb = 0.14;\nd = 0.2;\n\nq1 = aspectx;\nq2 = aspecty;\n\nq3 = startx;\nq4 = starty;\n\nq5 = a; // the model parameters are synchronized for the phase plot wave and the per-vertex warp\nq6 = b;\nq7 = d;\n\n\nvol = bass*8 + mid*5 + treb*3;\nm = m*0.97 + vol*0.08;\nmonitor = vol;\nbeat = above(vol,res)*above(vol,m)*above(vol,16);\ndiff = (1-beat)*diff + beat*(vol-res);\nres = beat*(vol + m*0.04) + (1-beat)*(res -  (0.1+diff*0.02)*60/fps);\nres = max(0,res);\n\nw = if(beat,rand(3.14*2),w);\nx = if(beat,rand(1),x);\ny = if(beat,rand(1),y);\n\n// below parameters belong to a synchronized affine transformation for waves and the per-vertex code (rotate, scale, translate)\n\nq26 = 0.5*x; // center for rotation and scaling (x)\nq27 = 0.5*y; // center for rotation and scaling (y)\nq28 = 1; // scale\nq29 = 0.4; // translate x\nq30 = 0.1; // translate y\nq31 = sin(w);\nq32 = cos(w);\nq25 = w;\n// TODO: compensate parameter changes for an invariant canvas pane via difference quotients ;)\n\n// integration\nbb = bb*0.98 + bass*0.5;\nmm = mm*0.98 + mid*0.5;\ntt = tt*0.98 + treb*0.5;\n\n// normalization\nmx = max(max(bb,mm),tt);\nmn = min(min(bb,mm),tt);\n\nh1 = (bb-mn)/(mx-mn);\nh2 = (mm-mn)/(mx-mn);\nh3 = (tt-mn)/(mx-mn);\n\n// integration again (for constant change in one variable)\nv = 0.1/fps;\nbm = bm + (h1-h2)*v;\nmt = mt + (h2-h3)*v;\nbt = bt + (h1-h3)*v;\n\n// emit\nq10 = bm;\nq11 = mt;\nq12 = bt;\nv = bm;\nq13 = sin(v);\nq14 = cos(v);","pixel_eqs_eel":"x = 0.5 + (x-0.5)*q1;\ny = 0.5 - (y-0.5)*q2;\n\nx = q26 + (x-q26)/q28 - q29;\ny = q27 + (y-q27)/q28 - q30;\n\n// have a nice warp effect? - rotate it like a shape!\n\n  angle = -q25;\n\n/////////////////////////////////////////////////////////\nX1 = x - q26;\nY1 = y - q27;\nx = q26 + cos(-angle)*X1 -sin(-angle)*Y1; // rotate the x/y pane\ny = q27 + sin(-angle)*X1 +cos(-angle)*Y1;\n/////////////////////////////////////////////////////////\n\n\ndx = x*(1-x)-q5*x*y/(x+q6);\ndy = -q7*y*(1-y/x);\n\ndx = -0.01*dx/q1;\ndy = -0.01*dy/q2;\n\n\n//dx = 0;\n//dy = 0;\n\n/////////////////////////////////////////////////////////\ndx1 = cos(angle)*dx - sin(angle)*dy; // and finally the dx/dy pane is rotated to match the x/y pane\ndy1 = sin(angle)*dx + cos(angle)*dy;\ndx = dx1*aspectx;\ndy = dy1*aspecty;\n/////////////////////////////////////////////////////////","warp":" shader_body { \n  vec3 ret_1;\n  ret_1.z = (texture (sampler_main, uv).z * 0.5);\n  vec2 tmpvar_2;\n  tmpvar_2 = ((uv_orig * texsize.xy) * texsize_noise_lq.zw);\n  vec2 tmpvar_3;\n  tmpvar_3 = (texsize.zw * 4.0);\n  vec2 tmpvar_4;\n  tmpvar_4.x = (((2.0 * \n    ((texture (sampler_blur1, (uv_orig + (vec2(1.0, 0.0) * tmpvar_3))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_orig - (vec2(1.0, 0.0) * tmpvar_3))).xyz * scale1) + bias1)\n  )).y * 0.5);\n  tmpvar_4.y = (((2.0 * \n    ((texture (sampler_blur1, (uv_orig + (vec2(0.0, 1.0) * tmpvar_3))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_orig - (vec2(0.0, 1.0) * tmpvar_3))).xyz * scale1) + bias1)\n  )).y * 0.5);\n  ret_1.y = texture (sampler_fw_main, clamp ((uv_orig + (\n    (tmpvar_4 * texsize.zw)\n   * 4.0)), 0.0, 1.0)).y;\n  ret_1.y = (ret_1.y + ((\n    (ret_1 - ((texture (sampler_blur1, uv_orig).xyz * scale1) + bias1))\n  .y * 0.025) + -0.014));\n  ret_1.y = (ret_1.y + ((texture (sampler_noise_lq, tmpvar_2).y - 0.5) * 0.02));\n  vec2 tmpvar_5;\n  tmpvar_5.x = (((2.0 * \n    ((texture (sampler_blur1, (uv_orig + (vec2(1.0, 0.0) * tmpvar_3))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_orig - (vec2(1.0, 0.0) * tmpvar_3))).xyz * scale1) + bias1)\n  )).x * 0.5);\n  tmpvar_5.y = (((2.0 * \n    ((texture (sampler_blur1, (uv_orig + (vec2(0.0, 1.0) * tmpvar_3))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_orig - (vec2(0.0, 1.0) * tmpvar_3))).xyz * scale1) + bias1)\n  )).x * 0.5);\n  ret_1.x = ((texture (sampler_main, (uv - \n    ((tmpvar_5 * texsize.zw) * 4.0)\n  )).x - (ret_1.y * 0.01)) + 0.004);\n  ret_1.x = (ret_1.x + ((\n    (texture (sampler_noise_lq, tmpvar_2).x - 0.5)\n   * 0.01) + (ret_1.z * 0.14)));\n  vec4 tmpvar_6;\n  tmpvar_6.w = 1.0;\n  tmpvar_6.xyz = ret_1;\n  ret = tmpvar_6.xyz;\n }","comp":" shader_body { \n  vec2 uv_1;\n  vec2 mirror_uv_2;\n  vec2 rotate_uv_3;\n  vec3 ret_4;\n  uv_1 = (0.5 + ((uv - 0.5) * 1.5));\n  vec2 tmpvar_5;\n  tmpvar_5 = ((uv_1 - 0.5) * aspect.xy);\n  vec2 tmpvar_6;\n  tmpvar_6.x = ((q14 * tmpvar_5.x) - (q13 * tmpvar_5.y));\n  tmpvar_6.y = ((q13 * tmpvar_5.x) + (q14 * tmpvar_5.y));\n  vec2 tmpvar_7;\n  tmpvar_7 = (0.5 + (tmpvar_6 * 2.0));\n  rotate_uv_3 = tmpvar_7;\n  vec2 numerator_8;\n  numerator_8 = (tmpvar_7 - vec2(0.0, 0.5));\n  vec2 denominator_9;\n  denominator_9 = (tmpvar_7 - vec2(1.0, 0.5));\n  vec2 tmpvar_10;\n  tmpvar_10.x = ((numerator_8.x * denominator_9.x) + (numerator_8.y * denominator_9.y));\n  tmpvar_10.y = ((numerator_8.y * denominator_9.x) - (numerator_8.x * denominator_9.y));\n  vec2 tmpvar_11;\n  tmpvar_11 = (((tmpvar_10 / \n    ((denominator_9.x * denominator_9.x) + (denominator_9.y * denominator_9.y))\n  ) + 0.5) - vec2(0.5, 0.5));\n  float tmpvar_12;\n  tmpvar_12 = sqrt(dot (tmpvar_11, tmpvar_11));\n  float tmpvar_13;\n  float tmpvar_14;\n  tmpvar_14 = (min (abs(\n    (tmpvar_11.x / tmpvar_11.y)\n  ), 1.0) / max (abs(\n    (tmpvar_11.x / tmpvar_11.y)\n  ), 1.0));\n  float tmpvar_15;\n  tmpvar_15 = (tmpvar_14 * tmpvar_14);\n  tmpvar_15 = (((\n    ((((\n      ((((-0.01213232 * tmpvar_15) + 0.05368138) * tmpvar_15) - 0.1173503)\n     * tmpvar_15) + 0.1938925) * tmpvar_15) - 0.3326756)\n   * tmpvar_15) + 0.9999793) * tmpvar_14);\n  tmpvar_15 = (tmpvar_15 + (float(\n    (abs((tmpvar_11.x / tmpvar_11.y)) > 1.0)\n  ) * (\n    (tmpvar_15 * -2.0)\n   + 1.570796)));\n  tmpvar_13 = (tmpvar_15 * sign((tmpvar_11.x / tmpvar_11.y)));\n  if ((abs(tmpvar_11.y) > (1e-08 * abs(tmpvar_11.x)))) {\n    if ((tmpvar_11.y < 0.0)) {\n      if ((tmpvar_11.x >= 0.0)) {\n        tmpvar_13 += 3.141593;\n      } else {\n        tmpvar_13 = (tmpvar_13 - 3.141593);\n      };\n    };\n  } else {\n    tmpvar_13 = (sign(tmpvar_11.x) * 1.570796);\n  };\n  vec2 tmpvar_16;\n  tmpvar_16.x = (tmpvar_13 * 0.1591549);\n  tmpvar_16.y = tmpvar_12;\n  vec2 tmpvar_17;\n  tmpvar_17.x = ((tmpvar_16.x * 2.0) + q11);\n  tmpvar_17.y = ((0.35 * log(tmpvar_12)) + q12);\n  vec2 tmpvar_18;\n  tmpvar_18 = (0.5 + (0.5 - abs(\n    ((fract((tmpvar_17 * 0.5)) * 2.0) - 1.0)\n  )));\n  mirror_uv_2 = tmpvar_18;\n  uv_1 = (0.5 + ((tmpvar_18 - 0.5) * 1.5));\n  vec2 tmpvar_19;\n  tmpvar_19 = (uv_1 - 0.5);\n  vec2 tmpvar_20;\n  tmpvar_20.x = ((q14 * tmpvar_19.x) - (q13 * tmpvar_19.y));\n  tmpvar_20.y = ((q13 * tmpvar_19.x) + (q14 * tmpvar_19.y));\n  rotate_uv_3 = (0.5 + (tmpvar_20 * 2.0));\n  vec2 numerator_21;\n  numerator_21 = (rotate_uv_3 - vec2(0.0, 0.5));\n  vec2 denominator_22;\n  denominator_22 = (rotate_uv_3 - vec2(1.0, 0.5));\n  vec2 tmpvar_23;\n  tmpvar_23.x = ((numerator_21.x * denominator_22.x) + (numerator_21.y * denominator_22.y));\n  tmpvar_23.y = ((numerator_21.y * denominator_22.x) - (numerator_21.x * denominator_22.y));\n  vec2 tmpvar_24;\n  tmpvar_24 = (((tmpvar_23 / \n    ((denominator_22.x * denominator_22.x) + (denominator_22.y * denominator_22.y))\n  ) + 0.5) - vec2(0.5, 0.5));\n  float tmpvar_25;\n  tmpvar_25 = sqrt(dot (tmpvar_24, tmpvar_24));\n  float tmpvar_26;\n  float tmpvar_27;\n  tmpvar_27 = (min (abs(\n    (tmpvar_24.x / tmpvar_24.y)\n  ), 1.0) / max (abs(\n    (tmpvar_24.x / tmpvar_24.y)\n  ), 1.0));\n  float tmpvar_28;\n  tmpvar_28 = (tmpvar_27 * tmpvar_27);\n  tmpvar_28 = (((\n    ((((\n      ((((-0.01213232 * tmpvar_28) + 0.05368138) * tmpvar_28) - 0.1173503)\n     * tmpvar_28) + 0.1938925) * tmpvar_28) - 0.3326756)\n   * tmpvar_28) + 0.9999793) * tmpvar_27);\n  tmpvar_28 = (tmpvar_28 + (float(\n    (abs((tmpvar_24.x / tmpvar_24.y)) > 1.0)\n  ) * (\n    (tmpvar_28 * -2.0)\n   + 1.570796)));\n  tmpvar_26 = (tmpvar_28 * sign((tmpvar_24.x / tmpvar_24.y)));\n  if ((abs(tmpvar_24.y) > (1e-08 * abs(tmpvar_24.x)))) {\n    if ((tmpvar_24.y < 0.0)) {\n      if ((tmpvar_24.x >= 0.0)) {\n        tmpvar_26 += 3.141593;\n      } else {\n        tmpvar_26 = (tmpvar_26 - 3.141593);\n      };\n    };\n  } else {\n    tmpvar_26 = (sign(tmpvar_24.x) * 1.570796);\n  };\n  vec2 tmpvar_29;\n  tmpvar_29.x = (tmpvar_26 * 0.1591549);\n  tmpvar_29.y = tmpvar_25;\n  vec2 tmpvar_30;\n  tmpvar_30.x = ((tmpvar_29.x * 2.0) + q11);\n  tmpvar_30.y = ((0.35 * log(tmpvar_25)) + q12);\n  mirror_uv_2 = (0.5 + (0.5 - abs(\n    ((fract((tmpvar_30 * 0.5)) * 2.0) - 1.0)\n  )));\n  uv_1 = (0.5 + ((mirror_uv_2 - 0.5) * 1.5));\n  vec2 tmpvar_31;\n  tmpvar_31 = (uv_1 - 0.5);\n  vec2 tmpvar_32;\n  tmpvar_32.x = ((q14 * tmpvar_31.x) - (q13 * tmpvar_31.y));\n  tmpvar_32.y = ((q13 * tmpvar_31.x) + (q14 * tmpvar_31.y));\n  rotate_uv_3 = (0.5 + (tmpvar_32 * 2.0));\n  vec2 numerator_33;\n  numerator_33 = (rotate_uv_3 - vec2(0.0, 0.5));\n  vec2 denominator_34;\n  denominator_34 = (rotate_uv_3 - vec2(1.0, 0.5));\n  vec2 tmpvar_35;\n  tmpvar_35.x = ((numerator_33.x * denominator_34.x) + (numerator_33.y * denominator_34.y));\n  tmpvar_35.y = ((numerator_33.y * denominator_34.x) - (numerator_33.x * denominator_34.y));\n  vec2 tmpvar_36;\n  tmpvar_36 = (((tmpvar_35 / \n    ((denominator_34.x * denominator_34.x) + (denominator_34.y * denominator_34.y))\n  ) + 0.5) - vec2(0.5, 0.5));\n  float tmpvar_37;\n  tmpvar_37 = sqrt(dot (tmpvar_36, tmpvar_36));\n  float tmpvar_38;\n  float tmpvar_39;\n  tmpvar_39 = (min (abs(\n    (tmpvar_36.x / tmpvar_36.y)\n  ), 1.0) / max (abs(\n    (tmpvar_36.x / tmpvar_36.y)\n  ), 1.0));\n  float tmpvar_40;\n  tmpvar_40 = (tmpvar_39 * tmpvar_39);\n  tmpvar_40 = (((\n    ((((\n      ((((-0.01213232 * tmpvar_40) + 0.05368138) * tmpvar_40) - 0.1173503)\n     * tmpvar_40) + 0.1938925) * tmpvar_40) - 0.3326756)\n   * tmpvar_40) + 0.9999793) * tmpvar_39);\n  tmpvar_40 = (tmpvar_40 + (float(\n    (abs((tmpvar_36.x / tmpvar_36.y)) > 1.0)\n  ) * (\n    (tmpvar_40 * -2.0)\n   + 1.570796)));\n  tmpvar_38 = (tmpvar_40 * sign((tmpvar_36.x / tmpvar_36.y)));\n  if ((abs(tmpvar_36.y) > (1e-08 * abs(tmpvar_36.x)))) {\n    if ((tmpvar_36.y < 0.0)) {\n      if ((tmpvar_36.x >= 0.0)) {\n        tmpvar_38 += 3.141593;\n      } else {\n        tmpvar_38 = (tmpvar_38 - 3.141593);\n      };\n    };\n  } else {\n    tmpvar_38 = (sign(tmpvar_36.x) * 1.570796);\n  };\n  vec2 tmpvar_41;\n  tmpvar_41.x = (tmpvar_38 * 0.1591549);\n  tmpvar_41.y = tmpvar_37;\n  vec2 tmpvar_42;\n  tmpvar_42.x = ((tmpvar_41.x * 2.0) + q11);\n  tmpvar_42.y = ((0.35 * log(tmpvar_37)) + q12);\n  mirror_uv_2 = (0.5 + (0.5 - abs(\n    ((fract((tmpvar_42 * 0.5)) * 2.0) - 1.0)\n  )));\n  uv_1 = (0.5 + ((mirror_uv_2 - 0.5) * 1.5));\n  vec2 tmpvar_43;\n  tmpvar_43 = (uv_1 - 0.5);\n  vec2 tmpvar_44;\n  tmpvar_44.x = ((q14 * tmpvar_43.x) - (q13 * tmpvar_43.y));\n  tmpvar_44.y = ((q13 * tmpvar_43.x) + (q14 * tmpvar_43.y));\n  rotate_uv_3 = (0.5 + (tmpvar_44 * 2.0));\n  vec2 numerator_45;\n  numerator_45 = (rotate_uv_3 - vec2(0.0, 0.5));\n  vec2 denominator_46;\n  denominator_46 = (rotate_uv_3 - vec2(1.0, 0.5));\n  vec2 tmpvar_47;\n  tmpvar_47.x = ((numerator_45.x * denominator_46.x) + (numerator_45.y * denominator_46.y));\n  tmpvar_47.y = ((numerator_45.y * denominator_46.x) - (numerator_45.x * denominator_46.y));\n  vec2 tmpvar_48;\n  tmpvar_48 = (((tmpvar_47 / \n    ((denominator_46.x * denominator_46.x) + (denominator_46.y * denominator_46.y))\n  ) + 0.5) - vec2(0.5, 0.5));\n  float tmpvar_49;\n  tmpvar_49 = sqrt(dot (tmpvar_48, tmpvar_48));\n  float tmpvar_50;\n  float tmpvar_51;\n  tmpvar_51 = (min (abs(\n    (tmpvar_48.x / tmpvar_48.y)\n  ), 1.0) / max (abs(\n    (tmpvar_48.x / tmpvar_48.y)\n  ), 1.0));\n  float tmpvar_52;\n  tmpvar_52 = (tmpvar_51 * tmpvar_51);\n  tmpvar_52 = (((\n    ((((\n      ((((-0.01213232 * tmpvar_52) + 0.05368138) * tmpvar_52) - 0.1173503)\n     * tmpvar_52) + 0.1938925) * tmpvar_52) - 0.3326756)\n   * tmpvar_52) + 0.9999793) * tmpvar_51);\n  tmpvar_52 = (tmpvar_52 + (float(\n    (abs((tmpvar_48.x / tmpvar_48.y)) > 1.0)\n  ) * (\n    (tmpvar_52 * -2.0)\n   + 1.570796)));\n  tmpvar_50 = (tmpvar_52 * sign((tmpvar_48.x / tmpvar_48.y)));\n  if ((abs(tmpvar_48.y) > (1e-08 * abs(tmpvar_48.x)))) {\n    if ((tmpvar_48.y < 0.0)) {\n      if ((tmpvar_48.x >= 0.0)) {\n        tmpvar_50 += 3.141593;\n      } else {\n        tmpvar_50 = (tmpvar_50 - 3.141593);\n      };\n    };\n  } else {\n    tmpvar_50 = (sign(tmpvar_48.x) * 1.570796);\n  };\n  vec2 tmpvar_53;\n  tmpvar_53.x = (tmpvar_50 * 0.1591549);\n  tmpvar_53.y = tmpvar_49;\n  vec2 tmpvar_54;\n  tmpvar_54.x = ((tmpvar_53.x * 2.0) + q11);\n  tmpvar_54.y = ((0.35 * log(tmpvar_49)) + q12);\n  mirror_uv_2 = (0.5 + (0.5 - abs(\n    ((fract((tmpvar_54 * 0.5)) * 2.0) - 1.0)\n  )));\n  uv_1 = mirror_uv_2;\n  vec2 tmpvar_55;\n  tmpvar_55 = (texsize.zw * 4.0);\n  vec3 tmpvar_56;\n  tmpvar_56 = (((texture (sampler_blur1, \n    (mirror_uv_2 + (vec2(1.0, 0.0) * tmpvar_55))\n  ).xyz * scale1) + bias1) - ((texture (sampler_blur1, \n    (mirror_uv_2 - (vec2(1.0, 0.0) * tmpvar_55))\n  ).xyz * scale1) + bias1));\n  vec3 tmpvar_57;\n  tmpvar_57 = (((texture (sampler_blur1, \n    (mirror_uv_2 + (vec2(0.0, 1.0) * tmpvar_55))\n  ).xyz * scale1) + bias1) - ((texture (sampler_blur1, \n    (mirror_uv_2 - (vec2(0.0, 1.0) * tmpvar_55))\n  ).xyz * scale1) + bias1));\n  vec2 tmpvar_58;\n  tmpvar_58.x = tmpvar_56.z;\n  tmpvar_58.y = tmpvar_57.z;\n  vec2 tmpvar_59;\n  tmpvar_59.x = tmpvar_56.y;\n  tmpvar_59.y = tmpvar_57.y;\n  vec2 tmpvar_60;\n  tmpvar_60 = ((mirror_uv_2 - (tmpvar_58 * 0.1)) + (tmpvar_59 * 0.06));\n  ret_4 = (((\n    ((texture (sampler_blur2, tmpvar_60).xyz * scale2) + bias2)\n  .x * \n    clamp ((1.0 - texture (sampler_main, mirror_uv_2).z), 0.0, 1.0)\n  ) * pow (hue_shader.yxz, vec3(8.0, 8.0, 8.0))) * 3.0);\n  ret_4 = (mix (ret_4, (\n    pow (hue_shader.yzx, vec3(8.0, 8.0, 8.0))\n   * 1.4), vec3((\n    (texture (sampler_main, tmpvar_60).x * 0.8)\n   + \n    ((texture (sampler_blur1, tmpvar_60).xyz * scale1) + bias1)\n  .x))) * clamp ((1.0 - \n    (((texture (sampler_blur1, mirror_uv_2).xyz * scale1) + bias1).y * 4.0)\n  ), 0.0, 1.0));\n  vec2 tmpvar_61;\n  tmpvar_61.x = tmpvar_56.y;\n  tmpvar_61.y = tmpvar_57.y;\n  vec3 tmpvar_62;\n  vec3 tmpvar_63;\n  tmpvar_63 = pow (hue_shader, vec3(8.0, 8.0, 8.0));\n  tmpvar_62 = mix (mix (ret_4, vec3(1.0, 1.0, 1.0), (\n    (tmpvar_63 * texture (sampler_main, clamp ((mirror_uv_2 - (tmpvar_61 * 2.0)), 0.0, 1.0)).z)\n   * 1.2)), (tmpvar_63.zxy * 1.8), texture (sampler_main, mirror_uv_2).yyy);\n  ret_4 = tmpvar_62;\n  vec4 tmpvar_64;\n  tmpvar_64.w = 1.0;\n  tmpvar_64.xyz = tmpvar_62;\n  ret = tmpvar_64.xyz;\n }"}