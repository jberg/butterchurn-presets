{"version":2,"baseVals":{"rating":4,"gammaadj":1,"wave_thick":1,"wrap":0,"wave_a":0.004,"wave_scale":9.731,"wave_smoothing":0,"wave_mystery":1,"modwavealphastart":1,"modwavealphaend":1,"warpanimspeed":0.442,"warpscale":7.315,"zoomexp":1.50374,"warp":0.08563,"wave_y":0.04,"ob_size":0,"ob_g":1,"ob_a":1,"ib_size":0,"ib_r":1,"ib_g":0,"ib_b":0.75,"ib_a":1,"mv_x":64,"mv_y":48,"mv_l":0,"mv_b":0,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{"sides":41,"additive":1,"num_inst":50,"rad":0.01,"ang":3.20442,"tex_zoom":6.23873,"g":1,"b":1,"a":0,"r2":1,"b2":1,"border_a":1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"index = instance*q32;\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\n\nang = gmegabuf(index+9);\nrad = gmegabuf(index+4)*2;\n\nr = gmegabuf(index+5);\ng = gmegabuf(index+6);\nb = gmegabuf(index+7);\n\nr2 = r; g2 = g; b2 = b;\n\n\nx = 0.5 + (x-0.5)/q2;","init_eqs_eel":"","frame_eqs_eel":"index = instance*q32;\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\n\nang = gmegabuf(index+9);\nrad = gmegabuf(index+4)*2;\n\nr = gmegabuf(index+5);\ng = gmegabuf(index+6);\nb = gmegabuf(index+7);\n\nr2 = r; g2 = g; b2 = b;\n\n\nx = 0.5 + (x-0.5)/q2;"},{"baseVals":{"sides":23,"additive":1,"num_inst":50,"x":0.74,"y":0.27,"rad":0.01,"tex_zoom":0.81948,"g":1,"b":1,"g2":0,"border_a":0,"enabled":0},"init_eqs_str":"vx = 0","frame_eqs_str":"sample = instance/(num_inst-1);\n\nx1 = 0.5;\ny1 = 0.5 + (q3-0.5)*0.01;\ny2 = 0.5;\nx = x1 + (sample-0.5)*0.2;\ny = y2*sample + y1*(1-sample);","init_eqs_eel":"vx = 0","frame_eqs_eel":"sample = instance/(num_inst-1);\n\nx1 = 0.5;\ny1 = 0.5 + (q3-0.5)*0.01;\ny2 = 0.5;\nx = x1 + (sample-0.5)*0.2;\ny = y2*sample + y1*(1-sample);"},{"baseVals":{"sides":100,"additive":1,"rad":0.0999,"tex_zoom":0.73458,"r":0,"g":1,"a":0,"border_a":1,"enabled":0},"init_eqs_str":"vx = 0","frame_eqs_str":"","init_eqs_eel":"vx = 0","frame_eqs_eel":""},{"baseVals":{"enabled":1,"sides":3,"additive":1,"num_inst":400,"rad":0.16283,"tex_zoom":0.73458,"g":1,"b":1,"a":0.5,"g2":0,"border_a":0},"init_eqs_str":"a.bending=0;a.ppo=0;a.index=0;a.i3=0;a.dir=0;a.i4=0;a.size=0;a.q2=0;a.q32=0;a.sample=0;a.i3=0;a.i4=0;","frame_eqs_str":"a.i3=.00001<Math.abs(equal(a.instance,0))?0:a.i3;a.i4=.00001<Math.abs(equal(a.instance,0))?0:a.i4;a.ppo=8;a.index=a.i4*a.q32;a.sample=mod(a.i3,a.ppo);a.size=40*a.gmegabuf[Math.floor(a.index+4)];a.x=a.gmegabuf[Math.floor(a.index)];a.y=a.gmegabuf[Math.floor(a.index+1)];a.ang=a.gmegabuf[Math.floor(a.index+9)];a.rad=.05*a.size;a.r=a.gmegabuf[Math.floor(a.index+5)];a.g=a.gmegabuf[Math.floor(a.index+6)];a.b=a.gmegabuf[Math.floor(a.index+7)];a.sample=div(a.sample,a.ppo);a.bending=\n5*a.gmegabuf[Math.floor(a.index+12)]+5*a.gmegabuf[Math.floor(a.index+10)];a.dir=-a.ang+(a.sample-.4)*a.bending;a.ang=1.5*Math.asin(1)-a.dir+.05*a.bending;a.x+=.06*(a.sample-.3)*Math.cos(a.dir)*a.size+Math.sin(a.dir)*a.size*a.bending*.01;a.y+=.06*(a.sample-.3)*Math.sin(a.dir)*a.size-Math.cos(a.dir)*a.size*a.bending*.01;a.x=.5+div(a.x-.5,a.q2);a.rad=1.5*a.rad-.05*a.sample*a.size;a.i3+=1;a.i4=.00001<Math.abs(equal(mod(a.i3,a.ppo),0))?a.i4+1:a.i4;","init_eqs_eel":"i3 = 0;\ni4 = 0;","frame_eqs_eel":"i3 = if(equal(instance,0),0,i3);\ni4 = if(equal(instance,0),0,i4);\nppo = 8;\nindex = i4*q32;\nsample = i3 % ppo;\n\nsize = gmegabuf(index+4)*40;\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\n\nang = gmegabuf(index+9);\nrad = size*0.05;\n\nr = gmegabuf(index+5);\ng = gmegabuf(index+6);\nb = gmegabuf(index+7);\n\n\nsample = sample/ppo;\nbending = gmegabuf(index + 12)*5 + gmegabuf(index + 10)*5;\ndir = -ang + (sample-0.4)*bending;\n\n ang =  asin(1)*1.5 - dir + bending*0.05;\n\nx = x + ((sample-0.3)*0.06*cos(dir)*size + sin(dir)*size*bending*0.01);\ny = y + ((sample-0.3)*0.06*sin(dir)*size - cos(dir)*size*bending*0.01);\n\nx = 0.5 + (x-0.5)/q2;\n\nrad = rad*1.5 - sample*0.05*size;\n\ni3 = i3 + 1;\ni4 = if( equal(i3%ppo,0), i4 +1, i4);"}],"waves":[{"baseVals":{"samples":452,"additive":1,"scaling":2.44415,"smoothing":0,"a":0.15,"enabled":0},"init_eqs_str":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_str":"t1 = 0;\nt2 = 0;","point_eqs_str":"ppo = 9;\nindex = t2*q32;\nsample = t1 % ppo;\n\nnindex = gmegabuf(index + q30); // the next neighbor's index\nnnindex = gmegabuf(index + q30+1); // the next neighbor's index\nnnnindex = gmegabuf(index + q30+2); // the next neighbor's index\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\nr = 0.5 + gmegabuf(index+5)*0.5;\ng = 0.5 + gmegabuf(index+6)*0.5;\nb = 0.5 + gmegabuf(index+7)*0.5;\n\nnx = gmegabuf(nindex);\nny = gmegabuf(nindex+1);\nnnx = gmegabuf(nnindex);\nnny = gmegabuf(nnindex+1);\nnnnx = gmegabuf(nnnindex);\nnnny = gmegabuf(nnnindex+1);\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q2;\nnx = 0.5 + (nx-0.5)/q2;\nny = 0.5 + (ny-0.5)/q2;\nnnx = 0.5 + (nnx-0.5)/q2;\nnny = 0.5 + (nny-0.5)/q2;\nnnnx = 0.5 + (nnnx-0.5)/q2;\nnnny = 0.5 + (nnny-0.5)/q2;\n\nx = if( equal(sample,2), nx, x);\ny = if( equal(sample,2), ny, y);\nx = if( equal(sample,4), nnx, x);\ny = if( equal(sample,4), nny, y);\nx = if( equal(sample,6), nnnx, x);\ny = if( equal(sample,6), nnny, y);\n\na = above(sample,1)*below(sample,ppo-1)*a;\n\nt1 = t1 + 1;\nt2 = if( equal(t1%ppo,0), t2 +1, t2);","init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_eel":"t1 = 0;\nt2 = 0;","point_eqs_eel":"ppo = 9;\nindex = t2*q32;\nsample = t1 % ppo;\n\nnindex = gmegabuf(index + q30); // the next neighbor's index\nnnindex = gmegabuf(index + q30+1); // the next neighbor's index\nnnnindex = gmegabuf(index + q30+2); // the next neighbor's index\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\nr = 0.5 + gmegabuf(index+5)*0.5;\ng = 0.5 + gmegabuf(index+6)*0.5;\nb = 0.5 + gmegabuf(index+7)*0.5;\n\nnx = gmegabuf(nindex);\nny = gmegabuf(nindex+1);\nnnx = gmegabuf(nnindex);\nnny = gmegabuf(nnindex+1);\nnnnx = gmegabuf(nnnindex);\nnnny = gmegabuf(nnnindex+1);\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q2;\nnx = 0.5 + (nx-0.5)/q2;\nny = 0.5 + (ny-0.5)/q2;\nnnx = 0.5 + (nnx-0.5)/q2;\nnny = 0.5 + (nny-0.5)/q2;\nnnnx = 0.5 + (nnnx-0.5)/q2;\nnnny = 0.5 + (nnny-0.5)/q2;\n\nx = if( equal(sample,2), nx, x);\ny = if( equal(sample,2), ny, y);\nx = if( equal(sample,4), nnx, x);\ny = if( equal(sample,4), nny, y);\nx = if( equal(sample,6), nnnx, x);\ny = if( equal(sample,6), nnny, y);\n\na = above(sample,1)*below(sample,ppo-1)*a;\n\nt1 = t1 + 1;\nt2 = if( equal(t1%ppo,0), t2 +1, t2);"},{"baseVals":{"enabled":1,"samples":65,"spectrum":1,"usedots":1,"thick":1,"additive":1,"scaling":0.33408,"smoothing":0,"a":0},"init_eqs_str":"a.d=0;a.q32=0;a.t8=0;a.t1=0;a.t2=0;a.t2=0;a.t3=0;a.t4=0;a.cl=0;","frame_eqs_str":"a.t8=1;a.t1=.5;a.t2=.9;","point_eqs_str":"a.d=0;a.y=.2+a.value1+a.value2;a.x=.9-.8*a.sample;a.gmegabuf[Math.floor((64*a.sample-1)*a.q32+14)]=a.value1+a.value2;","init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_eel":"t8 = 1;\n\nt1 = 0.5;\nt2 = 0.9;","point_eqs_eel":"d = 0;//d*0.85 + (value1)*1;\n\ny = 0.2 + value1+value2;\nx = 0.9 - sample*0.8;\n\ngmegabuf((sample*64-1)*q32 + 14) = value1 + value2;"},{"baseVals":{"samples":280,"additive":1,"scaling":5.92556,"smoothing":0,"a":0.5,"enabled":0},"init_eqs_str":"","frame_eqs_str":"t1 = 0;\nt2 = 0;\n\n","point_eqs_str":"// q32 number of attributes\n// q31 number of objects\n\nppo = 7; // number of points used for each object\nindex = t2*q32; // object's index\n\nx = 0.5 +(gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\n\n// collecting pairs of index and distance to the current object in a local buffer\ni = 0;\nj = 0;\nloop(q31,\n     d = sqrt( sqr(gmegabuf(index)-gmegabuf(i)) + sqr(gmegabuf(index+1)-gmegabuf(i+1)));\n     d = if( equal(d,0), 1, d);\n     megabuf(j)   = i; // store index/distance pairs\n     megabuf(j+1) = d;\n     j = j+2;\n     i = i+q32;\n    );\n\n// sort that buffer, but only 5 cycles for the 5 nearest objects\ni = 0;\nloop( 5,\n      j = i;\n      smallestfind = 100;\n      findindex = 0;\n      loop( q31-j,\n            distance =megabuf(j*2+1);\n            smaller = above( smallestfind, distance);\n            smallestfind = if(smaller, distance, smallestfind);\n            findindex = if( smaller, j*2, findindex);\n            j = j + 1;\n          );\n\n      // now that the nearest object was found, swap it to the buffer's top\n\n      j = megabuf(i);\n      d = megabuf(i+1);\n\n      megabuf(i)   = megabuf(findindex);\n      megabuf(i+1) = megabuf(findindex+1);\n      megabuf(findindex)   = j;\n      megabuf(findindex+1) = d;\n\n      i = i+1;\n    );\n\n\nindex2 = (t1)%ppo;\ni = megabuf(index2-2);\nxx = 0.5 + (gmegabuf(i)-0.5)/q2;\nyy = 0.5 + (gmegabuf(i+1)-0.5)/q2;\nw = asin(1)*index2/4;\n//xx = x + sin(w)*0.1;\n//yy = y + cos(w)*0.1;\nx = if( equal(index2%2,0), x, xx);\ny = if( equal(index2%2,0), y, yy);\n\n\na = below(index2,ppo-1)*above(index2,1)*a;\nr = 0.5 + gmegabuf(index + 5)*0.5;\ng = 0.5 + gmegabuf(index + 6)*0.5;\nb = 0.5 + gmegabuf(index + 7)*0.5;\n\n\nt2 = t2 + equal(t1%ppo,ppo-1);\nt1 = t1 + 1;\n\n//a = above(t1,128);","init_eqs_eel":"","frame_eqs_eel":"t1 = 0;\nt2 = 0;\n\n","point_eqs_eel":"// q32 number of attributes\n// q31 number of objects\n\nppo = 7; // number of points used for each object\nindex = t2*q32; // object's index\n\nx = 0.5 +(gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\n\n// collecting pairs of index and distance to the current object in a local buffer\ni = 0;\nj = 0;\nloop(q31,\n     d = sqrt( sqr(gmegabuf(index)-gmegabuf(i)) + sqr(gmegabuf(index+1)-gmegabuf(i+1)));\n     d = if( equal(d,0), 1, d);\n     megabuf(j)   = i; // store index/distance pairs\n     megabuf(j+1) = d;\n     j = j+2;\n     i = i+q32;\n    );\n\n// sort that buffer, but only 5 cycles for the 5 nearest objects\ni = 0;\nloop( 5,\n      j = i;\n      smallestfind = 100;\n      findindex = 0;\n      loop( q31-j,\n            distance =megabuf(j*2+1);\n            smaller = above( smallestfind, distance);\n            smallestfind = if(smaller, distance, smallestfind);\n            findindex = if( smaller, j*2, findindex);\n            j = j + 1;\n          );\n\n      // now that the nearest object was found, swap it to the buffer's top\n\n      j = megabuf(i);\n      d = megabuf(i+1);\n\n      megabuf(i)   = megabuf(findindex);\n      megabuf(i+1) = megabuf(findindex+1);\n      megabuf(findindex)   = j;\n      megabuf(findindex+1) = d;\n\n      i = i+1;\n    );\n\n\nindex2 = (t1)%ppo;\ni = megabuf(index2-2);\nxx = 0.5 + (gmegabuf(i)-0.5)/q2;\nyy = 0.5 + (gmegabuf(i+1)-0.5)/q2;\nw = asin(1)*index2/4;\n//xx = x + sin(w)*0.1;\n//yy = y + cos(w)*0.1;\nx = if( equal(index2%2,0), x, xx);\ny = if( equal(index2%2,0), y, yy);\n\n\na = below(index2,ppo-1)*above(index2,1)*a;\nr = 0.5 + gmegabuf(index + 5)*0.5;\ng = 0.5 + gmegabuf(index + 6)*0.5;\nb = 0.5 + gmegabuf(index + 7)*0.5;\n\n\nt2 = t2 + equal(t1%ppo,ppo-1);\nt1 = t1 + 1;\n\n//a = above(t1,128);"},{"baseVals":{"samples":15,"thick":1,"additive":1,"scaling":5.92556,"smoothing":0,"a":0.4,"enabled":0},"init_eqs_str":"t2 = 0","frame_eqs_str":"t1 = 0;\nt2 = 0;\nt3 = 0;\nt4 = 0.5;","point_eqs_str":"ppo = 5;\n\nindex = t2*q32;\nneighbor = 1;\nneighbor = gmegabuf(index+10+neighbor);\nx = 0.5 + (gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\nxx = 0.5 + ( gmegabuf(neighbor) - 0.5)/q2;\nyy = 0.5 + ( gmegabuf(neighbor+1) - 0.5)/q2;\n\nx = if( equal(t1 % 2, 0), x, xx);\ny = if( equal(t1 % 2, 0), y, yx);\n\n\nt2 = t2 + equal(t1,ppo);\nt1 = if(above(t1,ppo),t1-ppo,t1) + 1;\n","init_eqs_eel":"t2 = 0","frame_eqs_eel":"t1 = 0;\nt2 = 0;\nt3 = 0;\nt4 = 0.5;","point_eqs_eel":"ppo = 5;\n\nindex = t2*q32;\nneighbor = 1;\nneighbor = gmegabuf(index+10+neighbor);\nx = 0.5 + (gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\nxx = 0.5 + ( gmegabuf(neighbor) - 0.5)/q2;\nyy = 0.5 + ( gmegabuf(neighbor+1) - 0.5)/q2;\n\nx = if( equal(t1 % 2, 0), x, xx);\ny = if( equal(t1 % 2, 0), y, yx);\n\n\nt2 = t2 + equal(t1,ppo);\nt1 = if(above(t1,ppo),t1-ppo,t1) + 1;\n"}],"init_eqs_str":"a.fric=0;a.d=0;a.nliststart=0;a.w=0;a.random=0;a.index2=0;a.index=0;a.w2=0;a.rotatefactor=0;a.ref_ang=0;a.smaller=0;a.dt=0;a.q1=0;a.j=0;a.v=0;a.count=0;a.shock=0;a.nn=0;a.vrr=0;a.check=0;a.gravity=0;a.vr2=0;a.direction=0;a.bouncefactor=0;a.smallestfind=0;a.distance=0;a.bounce=0;a.vr=0;a.vv1=0;a.vv2=0;a.vrr2=0;a.w1=0;a.attributes=0;a.i=0;a.m2=0;a.hit=0;a.q2=0;a.m1=0;a.h=0;a.v1=0;a.acceleration=0;a.findindex=0;a.friction=0;a.pi2=0;a.sample=0;a.v2=0;a.dampening=0;for(var b=a.i=\n0;1048576>b;b++)a.gmegabuf[Math.floor(a.i)]=0,a.i+=1;a.count=50;a.attributes=32;a.nliststart=24;a.minradius=.004;a.maxradius=.04;a.v=0;for(b=a.index=0;b<a.count;b++)a.gmegabuf[Math.floor(a.index*a.attributes)]=div(rand(1E3),1E3),a.gmegabuf[Math.floor(a.index*a.attributes+1)]=div(rand(1E3),1E3),a.gmegabuf[Math.floor(a.index*a.attributes+2)]=a.v*(div(rand(1E3),1E3)-.5),a.gmegabuf[Math.floor(a.index*a.attributes+3)]=a.v*(div(rand(1E3),1E3)-.5),a.gmegabuf[Math.floor(a.index*a.attributes+4)]=a.minradius+\ndiv((a.maxradius-a.minradius)*(a.index+1),a.count),a.gmegabuf[Math.floor(a.index*a.attributes+5)]=0,a.gmegabuf[Math.floor(a.index*a.attributes+6)]=1,a.gmegabuf[Math.floor(a.index*a.attributes+7)]=1,a.gmegabuf[Math.floor(a.index*a.attributes+8)]=pow(a.gmegabuf[Math.floor(a.index*a.attributes+4)],3),a.gmegabuf[Math.floor(a.index*a.attributes+9)]=div(4*Math.asin(1)*rand(1E3),1E3),a.gmegabuf[Math.floor(a.index*a.attributes+10)]=0,a.gmegabuf[Math.floor(a.index*a.attributes+13)]=div(a.index,a.count-1),\na.gmegabuf[Math.floor(a.index*a.attributes+14)]=0,a.index+=1;a.q30=a.nliststart;a.q31=a.count;a.q32=a.attributes;","frame_eqs_str":"a.dt=div(1,a.fps);a.warp=0;a.zoom=1;a.wave_a=0;a.gravity=0*a.dt;a.dampening=0;a.friction=2048*a.dt;a.shock=.002;a.pi2=Math.asin(1);a.nn=3;a.check=2;a.bouncefactor=.1;a.rotatefactor=0;a.h=.5*(a.aspecty-1);a.w=.5*(a.aspectx-1);a.index=0;for(var c=a.index2=0;c<a.count;c++){a.random=div(rand(1E3),1E3);a.sample=a.gmegabuf[Math.floor(a.index+13)];a.gmegabuf[Math.floor(a.index+11)]=.92*a.gmegabuf[Math.floor(a.index+11)]-4*a.gmegabuf[Math.floor(a.index+12)]*a.dt+2*(a.random-.5)*a.dt*\na.gmegabuf[Math.floor(a.index+14)];a.gmegabuf[Math.floor(a.index+12)]+=60*a.gmegabuf[Math.floor(a.index+11)]*a.dt;a.v=sqrt(sqr(a.gmegabuf[Math.floor(a.index+2)])+sqr(a.gmegabuf[Math.floor(a.index+3)]));a.fric=Math.max(0,1-sqr(a.v*a.friction)-2*a.v);a.gmegabuf[Math.floor(a.index+2)]*=a.fric;a.gmegabuf[Math.floor(a.index+3)]*=a.fric;a.gmegabuf[Math.floor(a.index+10)]=a.gmegabuf[Math.floor(a.index+10)]*a.fric+a.v*a.gmegabuf[Math.floor(a.index+12)]*0;a.acceleration=0*a.random+.003*Math.abs(a.gmegabuf[Math.floor(a.index+\n11)]);a.direction=a.gmegabuf[Math.floor(a.index+9)]-a.pi2;a.gmegabuf[Math.floor(a.index+2)]+=Math.sin(a.direction)*a.acceleration;a.gmegabuf[Math.floor(a.index+3)]+=Math.cos(a.direction)*a.acceleration;a.gmegabuf[Math.floor(a.index)]+=60*a.gmegabuf[Math.floor(a.index+2)]*a.dt;a.gmegabuf[Math.floor(a.index+1)]+=60*a.gmegabuf[Math.floor(a.index+3)]*a.dt;a.gmegabuf[Math.floor(a.index+9)]+=.5*a.gmegabuf[Math.floor(a.index+10)];a.gmegabuf[Math.floor(a.index+3)]-=a.gravity;a.vr=Math.sin(a.gmegabuf[Math.floor(a.index+\n10)])*a.gmegabuf[Math.floor(a.index+4)];a.bounce=above(a.gmegabuf[Math.floor(a.index+1)],1-a.gmegabuf[Math.floor(a.index+4)]+a.w);a.gmegabuf[Math.floor(a.index+2)]=.00001<Math.abs(a.bounce)?a.gmegabuf[Math.floor(a.index+2)]+(a.vr+a.gmegabuf[Math.floor(a.index+2)])*a.rotatefactor:a.gmegabuf[Math.floor(a.index+2)];a.gmegabuf[Math.floor(a.index+3)]=.00001<Math.abs(a.bounce)?-Math.abs(a.gmegabuf[Math.floor(a.index+3)])*a.dampening-a.shock:a.gmegabuf[Math.floor(a.index+3)];a.vr=.00001<Math.abs(a.bounce)?\na.vr-(a.gmegabuf[Math.floor(a.index+2)]+a.vr)*(1-a.rotatefactor):a.vr;a.bounce=below(a.gmegabuf[Math.floor(a.index+1)],a.gmegabuf[Math.floor(a.index+4)]-a.w);a.gmegabuf[Math.floor(a.index+2)]=.00001<Math.abs(a.bounce)?a.gmegabuf[Math.floor(a.index+2)]+(a.vr-a.gmegabuf[Math.floor(a.index+2)])*a.rotatefactor:a.gmegabuf[Math.floor(a.index+2)];a.gmegabuf[Math.floor(a.index+3)]=.00001<Math.abs(a.bounce)?Math.abs(a.gmegabuf[Math.floor(a.index+3)])*a.dampening+a.shock:a.gmegabuf[Math.floor(a.index+3)];a.vr=\n.00001<Math.abs(a.bounce)?a.vr+(a.gmegabuf[Math.floor(a.index+2)]-a.vr)*(1-a.rotatefactor):a.vr;a.bounce=above(a.gmegabuf[Math.floor(a.index)],1-a.gmegabuf[Math.floor(a.index+4)]+a.h);a.gmegabuf[Math.floor(a.index+2)]=.00001<Math.abs(a.bounce)?-Math.abs(a.gmegabuf[Math.floor(a.index+2)])*a.dampening-a.shock:a.gmegabuf[Math.floor(a.index+2)];a.gmegabuf[Math.floor(a.index+3)]=.00001<Math.abs(a.bounce)?a.gmegabuf[Math.floor(a.index+3)]+(a.vr-a.gmegabuf[Math.floor(a.index+3)])*a.rotatefactor:a.gmegabuf[Math.floor(a.index+\n3)];a.vr=.00001<Math.abs(a.bounce)?a.vr+(a.gmegabuf[Math.floor(a.index+3)]-a.vr)*(1-a.rotatefactor):a.vr;a.bounce=below(a.gmegabuf[Math.floor(a.index)],a.gmegabuf[Math.floor(a.index+4)]-a.h);a.gmegabuf[Math.floor(a.index+2)]=.00001<Math.abs(a.bounce)?Math.abs(a.gmegabuf[Math.floor(a.index+2)])*a.dampening+a.shock:a.gmegabuf[Math.floor(a.index+2)];a.gmegabuf[Math.floor(a.index+3)]=.00001<Math.abs(a.bounce)?a.gmegabuf[Math.floor(a.index+3)]-(a.vr+a.gmegabuf[Math.floor(a.index+3)])*a.rotatefactor:a.gmegabuf[Math.floor(a.index+\n3)];a.vr=.00001<Math.abs(a.bounce)?a.vr-(a.gmegabuf[Math.floor(a.index+3)]+a.vr)*(1-a.rotatefactor):a.vr;a.gmegabuf[Math.floor(a.index+10)]=Math.asin(div(a.vr,a.gmegabuf[Math.floor(a.index+4)]));a.i=0;for(var b=a.j=0;b<a.count;b++)a.d=sqrt(sqr(a.gmegabuf[Math.floor(a.index)]-a.gmegabuf[Math.floor(a.i)])+sqr(a.gmegabuf[Math.floor(a.index+1)]-a.gmegabuf[Math.floor(a.i+1)])),a.d=.00001<Math.abs(equal(a.d,0))?10:a.d,a.d-=.5*(a.gmegabuf[Math.floor(a.index+4)]+a.gmegabuf[Math.floor(a.i+4)]),a.megabuf[Math.floor(a.j)]=\na.i,a.megabuf[Math.floor(a.j+1)]=a.d,a.j+=2,a.i+=a.attributes;for(b=a.i=0;b<a.nn;b++){a.j=a.i;a.smallestfind=10;a.findindex=-1;for(var d=0;d<a.count-a.j;d++)a.distance=a.megabuf[Math.floor(2*a.j+1)],a.smaller=above(a.smallestfind,a.distance),a.smallestfind=.00001<Math.abs(a.smaller)?a.distance:a.smallestfind,a.findindex=.00001<Math.abs(a.smaller)?2*a.j:a.findindex,a.j+=1;a.j=a.megabuf[Math.floor(2*a.i)];a.d=a.megabuf[Math.floor(2*a.i+1)];a.megabuf[Math.floor(2*a.i)]=a.megabuf[Math.floor(a.findindex)];\na.megabuf[Math.floor(2*a.i+1)]=a.megabuf[Math.floor(a.findindex+1)];a.megabuf[Math.floor(a.findindex)]=a.j;a.megabuf[Math.floor(a.findindex+1)]=a.d;a.i+=1}for(b=a.i=0;b<a.nn;b++)a.gmegabuf[Math.floor(a.index+a.nliststart+a.i)]=a.megabuf[Math.floor(2*a.i)],a.i+=1;for(b=a.i=0;b<a.check;b++)a.index2=a.megabuf[Math.floor(a.i)],a.hit=below(sqrt(sqr(a.gmegabuf[Math.floor(a.index)]-a.gmegabuf[Math.floor(a.index2)])+sqr(a.gmegabuf[Math.floor(a.index+1)]-a.gmegabuf[Math.floor(a.index2+1)])),a.gmegabuf[Math.floor(a.index+\n4)]+a.gmegabuf[Math.floor(a.index2+4)])*above(sqrt(sqr(a.gmegabuf[Math.floor(a.index)]-a.gmegabuf[Math.floor(a.index2)])+sqr(a.gmegabuf[Math.floor(a.index+1)]-a.gmegabuf[Math.floor(a.index2+1)])),sqrt(sqr(a.gmegabuf[Math.floor(a.index+0)]-a.gmegabuf[Math.floor(a.index2+0)]+a.gmegabuf[Math.floor(a.index+2)]-a.gmegabuf[Math.floor(a.index2+2)])+sqr(a.gmegabuf[Math.floor(a.index+1)]-a.gmegabuf[Math.floor(a.index2+1)]+a.gmegabuf[Math.floor(a.index+3)]-a.gmegabuf[Math.floor(a.index2+3)]))),a.ref_ang=Math.atan2(a.gmegabuf[Math.floor(a.index2)]-\na.gmegabuf[Math.floor(a.index)],a.gmegabuf[Math.floor(a.index2+1)]-a.gmegabuf[Math.floor(a.index+1)])+a.pi2,a.v1=sqrt(sqr(a.gmegabuf[Math.floor(a.index+2)])+sqr(a.gmegabuf[Math.floor(a.index+3)])),a.v2=sqrt(sqr(a.gmegabuf[Math.floor(a.index2+2)])+sqr(a.gmegabuf[Math.floor(a.index2+3)])),a.w1=Math.atan2(a.gmegabuf[Math.floor(a.index+2)],a.gmegabuf[Math.floor(a.index+3)]),a.w2=Math.atan2(a.gmegabuf[Math.floor(a.index2+2)],a.gmegabuf[Math.floor(a.index2+3)]),a.vr2=Math.sin(a.gmegabuf[Math.floor(a.index2+\n10)])*a.gmegabuf[Math.floor(a.index2+4)],a.m1=a.gmegabuf[Math.floor(a.index+8)],a.m2=a.gmegabuf[Math.floor(a.index2+8)],a.vv1=div((a.m1-a.m2)*a.v1+2*a.m2*a.v2,a.m1+a.m2),a.vv2=div((a.m2-a.m1)*a.v2+2*a.m1*a.v1,a.m1+a.m2),a.vrr=div((a.m1-a.m2)*a.vr+2*a.m2*a.vr2,a.m1+a.m2),a.vrr2=div((a.m2-a.m1)*a.vr2+2*a.m1*a.vr,a.m1+a.m2),a.gmegabuf[Math.floor(a.index+2)]=.00001<Math.abs(a.hit)?Math.sin(a.ref_ang)*a.v1*Math.cos(a.w1-a.ref_ang)+.1*(a.vr-a.vr2-Math.sin(a.ref_ang)*a.v1*Math.cos(a.w1-a.ref_ang))+Math.cos(a.ref_ang)*\na.vv1*Math.sin(a.w2-a.ref_ang):a.gmegabuf[Math.floor(a.index+2)],a.gmegabuf[Math.floor(a.index+3)]=.00001<Math.abs(a.hit)?Math.cos(a.ref_ang)*a.v1*Math.cos(a.w1-a.ref_ang)+.1*(a.vr-a.vr2-Math.cos(a.ref_ang)*a.v1*Math.cos(a.w1-a.ref_ang))-Math.sin(a.ref_ang)*a.vv1*Math.sin(a.w2-a.ref_ang):a.gmegabuf[Math.floor(a.index+3)],a.gmegabuf[Math.floor(a.index2+2)]=.00001<Math.abs(a.hit)?Math.sin(a.ref_ang)*a.v2*Math.cos(a.w2-a.ref_ang)+.1*(a.vr2-a.vr-Math.sin(a.ref_ang)*a.v2*Math.cos(a.w2-a.ref_ang))+Math.cos(a.ref_ang)*\na.vv2*Math.sin(a.w1-a.ref_ang):a.gmegabuf[Math.floor(a.index2+2)],a.gmegabuf[Math.floor(a.index2+3)]=.00001<Math.abs(a.hit)?Math.cos(a.ref_ang)*a.v2*Math.cos(a.w2-a.ref_ang)+.1*(a.vr2-a.vr-Math.cos(a.ref_ang)*a.v2*Math.cos(a.w2-a.ref_ang))-Math.sin(a.ref_ang)*a.vv2*Math.sin(a.w1-a.ref_ang):a.gmegabuf[Math.floor(a.index2+3)],a.vr=.00001<Math.abs(a.hit)?a.vr+(Math.cos(a.w1-a.ref_ang)*(a.v1-a.v2)-a.vr):a.vr,a.gmegabuf[Math.floor(a.index+10)]=Math.asin(div(a.vr,a.gmegabuf[Math.floor(a.index+4)])),a.vr2=\n.00001<Math.abs(a.hit)?a.vr2+(Math.cos(a.w2-a.ref_ang)*(a.v2-a.v1)-a.vr2):a.vr2,a.gmegabuf[Math.floor(a.index2+10)]=Math.asin(div(a.vr2,a.gmegabuf[Math.floor(a.index2+4)])),a.i+=2;a.index+=a.attributes}a.q1=a.aspectx;a.q2=a.aspecty;","pixel_eqs_str":"","init_eqs_eel":"// clear buffer\ni = 0; loop(1024*1024, gmegabuf(i) = 0; i = i+1;);\n\ncount = 50;\nattributes = 32;\nnListStart = 24; // starting index of neighbor list\n\nminradius = 0.004;\nmaxradius = 0.04;\nv = 0.0;\n\n// randomize initial coordinates\nindex = 0;\nloop(count,\n     gmegabuf(index*attributes) = rand(1000)/1000;\n     gmegabuf(index*attributes+1) = rand(1000)/1000;\n     gmegabuf(index*attributes+2) = v*(rand(1000)/1000-0.5);\n     gmegabuf(index*attributes+3) = v*(rand(1000)/1000-0.5);\n     gmegabuf(index*attributes+4) = minradius + (maxradius-minradius)*(index+1)/count;\n     gmegabuf(index*attributes+5) = 0;\n     gmegabuf(index*attributes+6) = 1;\n     gmegabuf(index*attributes+7) = 1;\n     gmegabuf(index*attributes+8) = pow(gmegabuf(index*attributes+4),3) ;\n     gmegabuf(index*attributes+9) = 4*asin(1)*rand(1000)/1000;\n     gmegabuf(index*attributes+10) = 0;\n     gmegabuf(index*attributes+13) = index/(count-1);\n     gmegabuf(index*attributes+14) = 0;\n     index = index+1;\n    );\n\nq30 = nListStart;\nq31 = count;\nq32 = attributes;\n\n// 0, x\n// 1, y\n// 2, vx\n// 3, vy\n// 4, radius\n// 5, red\n// 6, green\n// 7, blue\n// 8, mass\n// 9, angle\n// 10, rotation\n// 11, bend force\n// 12, bending\n// 13, sample\n// 14, spectrum","frame_eqs_eel":"dt = 1/fps;\n\nwarp = 0;\nzoom = 1;\nwave_a = 0;\n\ngravity = 0.0015*dt*0;\ndampening = 0;\nfriction = 2048*dt;\nshock = 0.002;\npi2 = asin(1);\n\nnn = 3; // number of nearest neighbors to search, reduce if not needed\n        // provide enough attributes, otherwise the next object's coordinate will be overwritten\n        // collision detection is based on nearest neighbors, so keep it at least at 1.\n\ncheck = 2; // how many neighbors will be checked for a possible collision. may not be above nn.\n           // raise to avoid odd behavior in clusters of touching objects.\n\nbouncefactor = 0.1;\nrotatefactor = 0; // relation between angular and translative momentum, when object hits a border. this is an empirical value for a convincing impression\n\n\n\nh = (aspecty-1)*0.5; w = (aspectx-1)*0.5;\nindex = 0; index2 = 0;\nloop(count,\n\n     random = rand(1000)/1000;\n     sample = gmegabuf(index+13);\n\n     // bend force\n     gmegabuf(index + 11) = gmegabuf(index + 11)*0.92 - 4*gmegabuf(index+12)*dt + 2*(random-0.5)*dt*gmegabuf(index+14);\n\n     // bend\n     gmegabuf(index + 12) += 60*gmegabuf(index + 11)*dt;\n\n     v = sqrt( sqr( gmegabuf(index + 2) ) + sqr( gmegabuf(index + 3) ) );\n\n     // apply friction\n     fric = max(0,1 - sqr(v*friction) - v*2);\n     gmegabuf(index + 2) *= fric;\n     gmegabuf(index + 3) *= fric;\n\n     // apply direction change\n     gmegabuf(index + 10) = gmegabuf(index + 10)*fric +  v*gmegabuf(index +12)*0;\n\n     // apply acceleration force\n     acceleration = random*0.000 + abs(gmegabuf(index+11))*0.003;\n     direction = gmegabuf(index + 9) - pi2;\n     gmegabuf(index + 2) += sin(direction)*acceleration;\n     gmegabuf(index + 3) += cos(direction)*acceleration;\n\n     // adding velocity vectors\n     gmegabuf(index) = gmegabuf(index) + gmegabuf(index+2)*60*dt;\n     gmegabuf(index+1) = gmegabuf(index+1) + gmegabuf(index+3)*60*dt;\n     gmegabuf(index+9) = gmegabuf(index+9) + gmegabuf(index+10)*0.5;\n\n     // applying gravity\n     gmegabuf(index+3) = gmegabuf(index+3) - gravity;\n\n     vr = sin(gmegabuf(index+10))*gmegabuf(index+4); // rotation speed at the surface\n\n     // bounce off ceiling\n     bounce = above( gmegabuf(index+1), 1 - gmegabuf(index+4) + w);\n     gmegabuf(index+2) = if( bounce, gmegabuf(index+2) + (vr+gmegabuf(index+2))*rotatefactor, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, -abs(gmegabuf(index+3))*dampening - shock, gmegabuf(index+3));\n     vr = if( bounce, vr - (gmegabuf(index+2) + vr)*(1-rotatefactor), vr);\n\n     // bounce off floor\n     bounce = below( gmegabuf(index+1), gmegabuf(index+4) - w);\n     gmegabuf(index+2) = if( bounce, gmegabuf(index+2) + (vr-gmegabuf(index+2))*rotatefactor, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, abs(gmegabuf(index+3))*dampening + shock, gmegabuf(index+3));\n     vr = if( bounce, vr + (gmegabuf(index+2) - vr)*(1-rotatefactor), vr);\n\n     // bounce off right border\n     bounce = above( gmegabuf(index), 1 - gmegabuf(index+4) + h);\n     gmegabuf(index+2) = if( bounce, -abs(gmegabuf(index+2))*dampening - shock, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, gmegabuf(index+3) + (vr-gmegabuf(index+3))*rotatefactor, gmegabuf(index+3));\n     vr = if( bounce, vr + (gmegabuf(index+3) - vr)*(1-rotatefactor), vr);\n\n     // bounce off left border\n     bounce = below( gmegabuf(index), gmegabuf(index+4) - h);\n     gmegabuf(index+2) = if( bounce, abs(gmegabuf(index+2))*dampening + shock, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, gmegabuf(index+3) - (vr+gmegabuf(index+3))*rotatefactor, gmegabuf(index+3));\n     vr = if( bounce, vr - (gmegabuf(index+3) + vr)*(1-rotatefactor), vr);\n\n     gmegabuf(index+10) = asin(vr/gmegabuf(index+4));\n\n     i = 0; j = 0; // collecting pairs of index and distance to the current object in a local buffer\n     loop( count,\n           d = sqrt( sqr(gmegabuf(index)-gmegabuf(i)) + sqr(gmegabuf(index+1)-gmegabuf(i+1)));\n           d = if( equal(d,0), 10, d); // leave out comparison with itself (where d == 0, set d to a high value)\n           d = d - (gmegabuf(index+4)+gmegabuf(i+4))*0.5; // subtract radius (surface to surface distance)\n           megabuf(j)   = i; // store index/distance pairs\n           megabuf(j+1) = d;\n           j = j+2;\n           i = i+attributes; );\n     i = 0; // sort that buffer, but only as many cycles as needed for the _nn_ nearest neighbors\n     loop( nn,\n           j = i; smallestfind = 10; findindex = -1;\n           loop( count-j,\n                 distance =megabuf(j*2+1);\n                 smaller = above( smallestfind, distance);\n                 smallestfind = if(smaller, distance, smallestfind);\n                 findindex = if( smaller, j*2, findindex);\n                 j = j + 1; );\n           j = megabuf(i*2); d = megabuf(i*2+1);\n           megabuf(i*2)   = megabuf(findindex);\n           megabuf(i*2+1) = megabuf(findindex+1);\n           megabuf(findindex)   = j;\n           megabuf(findindex+1) = d;\n           i = i+1;\n         );\n     i = 0; // storing the indexes of the nearest neighbors in the list\n     loop( nn,\n           gmegabuf(index + nListStart + i) = megabuf(i*2);\n           i = i +1;\n         );\n     i = 0; // collision detection and impulse transmission below\n     loop( check,\n           index2 = megabuf(i);\n           hit = below( sqrt( sqr( gmegabuf(index) - gmegabuf(index2)) +\n                              sqr( gmegabuf(index+1) - gmegabuf(index2+1))),\n                        gmegabuf(index + 4) + gmegabuf(index2 + 4)\n                      )\n                 *\n                 above( sqrt( sqr( gmegabuf(index)   - gmegabuf(index2))+\n                        sqr( gmegabuf(index+1) - gmegabuf(index2+1))),\n                        sqrt( sqr( gmegabuf(index+0) - gmegabuf(index2+0)+\n                                   gmegabuf(index+2) - gmegabuf(index2+2))+\n                              sqr( gmegabuf(index+1) - gmegabuf(index2+1)+\n                                   gmegabuf(index+3) - gmegabuf(index2+3)) ) );\n           ref_ang = atan2( gmegabuf(index2)-gmegabuf(index), // calculating the angle of the common tangent\n                            gmegabuf(index2 + 1)-gmegabuf(index + 1)) + pi2;\n           v1 = sqrt(sqr( gmegabuf(index + 2)) + sqr( gmegabuf(index + 3))); // velocity of object1\n           v2 = sqrt(sqr( gmegabuf(index2 + 2)) + sqr( gmegabuf(index2 + 3)));  // velocity of object2\n           w1 = atan2( gmegabuf(index + 2), gmegabuf(index + 3));   // object1 motion angle\n           w2 = atan2( gmegabuf(index2 + 2), gmegabuf(index2 + 3)); // object2 motion angle\n           vr2 = sin(gmegabuf(index2 + 10))*gmegabuf(index2+4); // the other object's surface velocity\n           m1 = gmegabuf(index + 8); m2 = gmegabuf(index2 + 8);\n           vv1 = ((m1-m2)*v1 + 2*m2*v2)/(m1+m2); vv2 = ((m2-m1)*v2 + 2*m1*v1)/(m1+m2);\n           vrr = ((m1-m2)*vr + 2*m2*vr2)/(m1+m2); vrr2 = ((m2-m1)*vr2 + 2*m1*vr)/(m1+m2);\n\n           gmegabuf( index + 2) = if( hit, sin(ref_ang)*v1*cos(w1-ref_ang) + ((vr-vr2)-sin(ref_ang)*v1*cos(w1-ref_ang))*0.1\n                                         + cos(ref_ang)*vv1*sin(w2-ref_ang),\n                                                  gmegabuf( index + 2) );\n\n           gmegabuf( index + 3) = if( hit, cos(ref_ang)*v1*cos(w1-ref_ang) + ((vr-vr2)-cos(ref_ang)*v1*cos(w1-ref_ang))*0.1\n                                         - sin(ref_ang)*vv1*sin(w2-ref_ang),\n                                                 gmegabuf( index + 3) );\n\n           gmegabuf( index2 + 2) = if( hit, sin(ref_ang)*v2*cos(w2-ref_ang) + ((vr2-vr)-sin(ref_ang)*v2*cos(w2-ref_ang))*0.1\n                                          + cos(ref_ang)*vv2*sin(w1-ref_ang),\n                                                  gmegabuf( index2 + 2) );\n\n           gmegabuf( index2 + 3) = if( hit, cos(ref_ang)*v2*cos(w2-ref_ang) + ((vr2-vr)-cos(ref_ang)*v2*cos(w2-ref_ang))*0.1\n                                          - sin(ref_ang)*vv2*sin(w1-ref_ang),\n                                                  gmegabuf( index2 + 3) );\n\n           vr = if( hit, vr + (cos(w1-ref_ang)*(v1-v2)-vr) , vr);\n           gmegabuf( index + 10) = asin( vr / gmegabuf(index+4) );\n\n           vr2 = if( hit, vr2 + (cos(w2-ref_ang)*(v2-v1)-vr2) , vr2);\n           gmegabuf( index2 + 10) = asin( vr2 / gmegabuf(index2+4) );\n\n           i=i+2;\n         );\n     index = index+attributes;\n    );\n\n\nq1 = aspectx;\nq2 = aspecty;","pixel_eqs_eel":"","warp":" shader_body { \n  vec3 ret_1;\n  ret_1.z = (texture (sampler_main, uv).z * 0.5);\n  vec2 tmpvar_2;\n  tmpvar_2 = ((uv_orig * texsize.xy) * texsize_noise_lq.zw);\n  vec2 tmpvar_3;\n  tmpvar_3 = (texsize.zw * 4.0);\n  vec2 tmpvar_4;\n  tmpvar_4.x = (((2.0 * \n    ((texture (sampler_blur1, (uv_orig + (vec2(1.0, 0.0) * tmpvar_3))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_orig - (vec2(1.0, 0.0) * tmpvar_3))).xyz * scale1) + bias1)\n  )).y * 0.5);\n  tmpvar_4.y = (((2.0 * \n    ((texture (sampler_blur1, (uv_orig + (vec2(0.0, 1.0) * tmpvar_3))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_orig - (vec2(0.0, 1.0) * tmpvar_3))).xyz * scale1) + bias1)\n  )).y * 0.5);\n  ret_1.y = texture (sampler_fw_main, clamp ((uv_orig + (\n    (tmpvar_4 * texsize.zw)\n   * 4.0)), 0.0, 1.0)).y;\n  ret_1.y = (ret_1.y + ((\n    (ret_1 - ((texture (sampler_blur1, uv_orig).xyz * scale1) + bias1))\n  .y * 0.025) + -0.014));\n  ret_1.y = (ret_1.y + ((texture (sampler_noise_lq, tmpvar_2).y - 0.5) * 0.02));\n  vec2 tmpvar_5;\n  tmpvar_5.x = (((2.0 * \n    ((texture (sampler_blur1, (uv_orig + (vec2(1.0, 0.0) * tmpvar_3))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_orig - (vec2(1.0, 0.0) * tmpvar_3))).xyz * scale1) + bias1)\n  )).x * 0.5);\n  tmpvar_5.y = (((2.0 * \n    ((texture (sampler_blur1, (uv_orig + (vec2(0.0, 1.0) * tmpvar_3))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_orig - (vec2(0.0, 1.0) * tmpvar_3))).xyz * scale1) + bias1)\n  )).x * 0.5);\n  ret_1.x = ((texture (sampler_main, (uv - \n    ((tmpvar_5 * texsize.zw) * 4.0)\n  )).x - (ret_1.y * 0.01)) + 0.004);\n  ret_1.x = (ret_1.x + ((\n    (texture (sampler_noise_lq, tmpvar_2).x - 0.5)\n   * 0.01) + (ret_1.z * 0.14)));\n  vec4 tmpvar_6;\n  tmpvar_6.w = 1.0;\n  tmpvar_6.xyz = ret_1;\n  ret = tmpvar_6.xyz;\n }","comp":" shader_body { \n  vec3 ret_1;\n  vec2 tmpvar_2;\n  tmpvar_2 = (texsize.zw * 4.0);\n  vec2 tmpvar_3;\n  tmpvar_3.x = (((2.0 * \n    ((texture (sampler_blur1, (uv + (vec2(1.0, 0.0) * tmpvar_2))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv - (vec2(1.0, 0.0) * tmpvar_2))).xyz * scale1) + bias1)\n  )) * 0.5).y;\n  tmpvar_3.y = (((2.0 * \n    ((texture (sampler_blur1, (uv + (vec2(0.0, 1.0) * tmpvar_2))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv - (vec2(0.0, 1.0) * tmpvar_2))).xyz * scale1) + bias1)\n  )) * 0.5).y;\n  vec2 tmpvar_4;\n  tmpvar_4 = (uv - ((tmpvar_3 * texsize.zw) * 128.0));\n  vec4 tmpvar_5;\n  tmpvar_5 = texture (sampler_main, uv);\n  ret_1 = (((\n    ((texture (sampler_blur2, tmpvar_4).xyz * scale2) + bias2)\n  .x * \n    clamp ((1.0 - tmpvar_5.y), 0.0, 1.0)\n  ) * pow (hue_shader.yxz, vec3(8.0, 8.0, 8.0))) * 3.0);\n  ret_1 = (mix (mix (ret_1, \n    (pow (hue_shader.yzx, vec3(8.0, 8.0, 8.0)) * 1.4)\n  , vec3(\n    ((texture (sampler_main, tmpvar_4).x * 0.8) + ((texture (sampler_blur1, tmpvar_4).xyz * scale1) + bias1).x)\n  )), vec3(1.0, 1.0, 1.0), (\n    (pow (hue_shader, vec3(8.0, 8.0, 8.0)) * texture (sampler_main, clamp (uv, 0.0, 1.0)).y)\n   * 1.2)) * clamp ((1.0 - tmpvar_5.z), 0.0, 1.0));\n  vec4 tmpvar_6;\n  tmpvar_6.w = 1.0;\n  tmpvar_6.xyz = ret_1;\n  ret = tmpvar_6.xyz;\n }","warp_hlsl":"shader_body\n{\n//uv = uv_orig;\nret.z = GetPixel(uv).z*0.5;\n\n   float pixelDistance   = 4;\n   float motionStrength  = 4;\n\n   float diffusionFactor = 1;\n   float decay           = -0.014;\n\n   float2 uv_y = lerp(uv_orig,uv,0);\n   float2 dither_uv = uv_orig*texsize.xy*texsize_noise_lq.zw*diffusionFactor;\n\n   float2 d = texsize.zw*pixelDistance;\n   float1 dx = ( 2*GetBlur1(uv_y + float2(1,0)*d) - 2*GetBlur1(uv_y-float2(1,0)*d) ).y*0.5;\n   float1 dy = ( 2*GetBlur1(uv_y + float2(0,1)*d) - 2*GetBlur1(uv_y-float2(0,1)*d) ).y*0.5;\n\n   float2 my_uv = uv_y + float2(dx,dy)*texsize.zw*motionStrength;\n\n   ret.y = tex2D( sampler_fw_main, saturate(my_uv)).y;\n\n   ret.y += (ret - GetBlur1(uv_y)).y*0.025 + decay;\n\n\n   ret.y += (tex2D(sampler_noise_lq, dither_uv).y-0.5)*0.02;\n\n   dx = ( 2*GetBlur1(uv_y + float2(1,0)*d) - 2*GetBlur1(uv_y-float2(1,0)*d) ).x*0.5;\n   dy = ( 2*GetBlur1(uv_y + float2(0,1)*d) - 2*GetBlur1(uv_y-float2(0,1)*d) ).x*0.5;\n\n   my_uv = uv - float2(dx,dy)*texsize.zw*motionStrength;\n\nret.x = GetPixel(my_uv).x - ret.y*0.01 + 0.004;\nret.x += (tex2D(sampler_noise_lq, dither_uv).x-0.5)*0.01 + ret.z*0.14;\n}","comp_hlsl":"shader_body\n{\n    float2 d = texsize.zw*4;\n    float3 dx = ( 2*GetBlur1(uv+float2(1,0)*d)-2*GetBlur1(uv-float2(1,0)*d) )*0.5;\n    float3 dy = ( 2*GetBlur1(uv+float2(0,1)*d)-2*GetBlur1(uv-float2(0,1)*d) )*0.5;\n\nfloat2 uv_x = uv - float2(dx.y,dy.y)*texsize.zw*128;\nret = GetBlur2(uv_x).x*saturate(1-GetPixel(uv).y)*pow(hue_shader.yxz,8)*3;\nret = lerp(ret,pow(hue_shader.yzx,8)*1.4,GetPixel(uv_x).x*0.8 + GetBlur1(uv_x).x);\nret = lerp(ret,1,pow(hue_shader,8)*GetPixel(saturate(uv - float2(dx.z,dy.z)*2*0)).y*1.2);\nret *= saturate(1-GetPixel(uv).z);\n}"}