{"version":2,"baseVals":{"rating":4,"gammaadj":1,"wave_thick":1,"wrap":0,"wave_a":0.004,"wave_scale":9.731,"wave_smoothing":0,"wave_mystery":1,"modwavealphastart":1,"modwavealphaend":1,"warpanimspeed":0.442,"warpscale":7.315,"zoomexp":1.50374,"warp":0.08563,"wave_y":0.04,"ob_size":0,"ob_g":1,"ob_a":1,"ib_size":0,"ib_r":1,"ib_g":0,"ib_b":0.75,"ib_a":1,"mv_x":64,"mv_y":48,"mv_l":0,"mv_b":0,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{"sides":41,"additive":1,"num_inst":50,"rad":0.01,"ang":3.20442,"tex_zoom":6.23873,"g":1,"b":1,"a":0,"r2":1,"b2":1,"border_a":1,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"index = instance*q32;\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\n\nang = gmegabuf(index+9);\nrad = gmegabuf(index+4)*2;\n\nr = gmegabuf(index+5);\ng = gmegabuf(index+6);\nb = gmegabuf(index+7);\n\nr2 = r; g2 = g; b2 = b;\n\n\nx = 0.5 + (x-0.5)/q2;"},{"baseVals":{"sides":23,"additive":1,"num_inst":50,"x":0.74,"y":0.27,"rad":0.01,"tex_zoom":0.81948,"g":1,"b":1,"g2":0,"border_a":0,"enabled":0},"init_eqs_eel":"vx = 0","frame_eqs_eel":"sample = instance/(num_inst-1);\n\nx1 = 0.5;\ny1 = 0.5 + (q3-0.5)*0.01;\ny2 = 0.5;\nx = x1 + (sample-0.5)*0.2;\ny = y2*sample + y1*(1-sample);"},{"baseVals":{"sides":100,"additive":1,"rad":0.0999,"tex_zoom":0.73458,"r":0,"g":1,"a":0,"border_a":1,"enabled":0},"init_eqs_eel":"vx = 0","frame_eqs_eel":""},{"baseVals":{"enabled":1,"sides":3,"additive":1,"num_inst":400,"rad":0.16283,"tex_zoom":0.73458,"g":1,"b":1,"a":0.5,"g2":0,"border_a":0},"init_eqs_eel":"i3 = 0;\ni4 = 0;","frame_eqs_eel":"i3 = if(equal(instance,0),0,i3);\ni4 = if(equal(instance,0),0,i4);\nppo = 8;\nindex = i4*q32;\nsample = i3 % ppo;\n\nsize = gmegabuf(index+4)*40;\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\n\nang = gmegabuf(index+9);\nrad = size*0.05;\n\nr = gmegabuf(index+5);\ng = gmegabuf(index+6);\nb = gmegabuf(index+7);\n\n\nsample = sample/ppo;\nbending = gmegabuf(index + 12)*5 + gmegabuf(index + 10)*5;\ndir = -ang + (sample-0.4)*bending;\n\n ang =  asin(1)*1.5 - dir + bending*0.05;\n\nx = x + ((sample-0.3)*0.06*cos(dir)*size + sin(dir)*size*bending*0.01);\ny = y + ((sample-0.3)*0.06*sin(dir)*size - cos(dir)*size*bending*0.01);\n\nx = 0.5 + (x-0.5)/q2;\n\nrad = rad*1.5 - sample*0.05*size;\n\ni3 = i3 + 1;\ni4 = if( equal(i3%ppo,0), i4 +1, i4);"}],"waves":[{"baseVals":{"samples":452,"additive":1,"scaling":2.44415,"smoothing":0,"a":0.15,"enabled":0},"init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_eel":"t1 = 0;\nt2 = 0;","point_eqs_eel":"ppo = 9;\nindex = t2*q32;\nsample = t1 % ppo;\n\nnindex = gmegabuf(index + q30); // the next neighbor's index\nnnindex = gmegabuf(index + q30+1); // the next neighbor's index\nnnnindex = gmegabuf(index + q30+2); // the next neighbor's index\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\nr = 0.5 + gmegabuf(index+5)*0.5;\ng = 0.5 + gmegabuf(index+6)*0.5;\nb = 0.5 + gmegabuf(index+7)*0.5;\n\nnx = gmegabuf(nindex);\nny = gmegabuf(nindex+1);\nnnx = gmegabuf(nnindex);\nnny = gmegabuf(nnindex+1);\nnnnx = gmegabuf(nnnindex);\nnnny = gmegabuf(nnnindex+1);\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q2;\nnx = 0.5 + (nx-0.5)/q2;\nny = 0.5 + (ny-0.5)/q2;\nnnx = 0.5 + (nnx-0.5)/q2;\nnny = 0.5 + (nny-0.5)/q2;\nnnnx = 0.5 + (nnnx-0.5)/q2;\nnnny = 0.5 + (nnny-0.5)/q2;\n\nx = if( equal(sample,2), nx, x);\ny = if( equal(sample,2), ny, y);\nx = if( equal(sample,4), nnx, x);\ny = if( equal(sample,4), nny, y);\nx = if( equal(sample,6), nnnx, x);\ny = if( equal(sample,6), nnny, y);\n\na = above(sample,1)*below(sample,ppo-1)*a;\n\nt1 = t1 + 1;\nt2 = if( equal(t1%ppo,0), t2 +1, t2);"},{"baseVals":{"enabled":1,"samples":65,"spectrum":1,"usedots":1,"thick":1,"additive":1,"scaling":0.33408,"smoothing":0,"a":0},"init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_eel":"t8 = 1;\n\nt1 = 0.5;\nt2 = 0.9;","point_eqs_eel":"d = 0;//d*0.85 + (value1)*1;\n\ny = 0.2 + value1+value2;\nx = 0.9 - sample*0.8;\n\ngmegabuf((sample*64-1)*q32 + 14) = value1 + value2;"},{"baseVals":{"samples":280,"additive":1,"scaling":5.92556,"smoothing":0,"a":0.5,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"t1 = 0;\nt2 = 0;\n\n","point_eqs_eel":"// q32 number of attributes\n// q31 number of objects\n\nppo = 7; // number of points used for each object\nindex = t2*q32; // object's index\n\nx = 0.5 +(gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\n\n// collecting pairs of index and distance to the current object in a local buffer\ni = 0;\nj = 0;\nloop(q31,\n     d = sqrt( sqr(gmegabuf(index)-gmegabuf(i)) + sqr(gmegabuf(index+1)-gmegabuf(i+1)));\n     d = if( equal(d,0), 1, d);\n     megabuf(j)   = i; // store index/distance pairs\n     megabuf(j+1) = d;\n     j = j+2;\n     i = i+q32;\n    );\n\n// sort that buffer, but only 5 cycles for the 5 nearest objects\ni = 0;\nloop( 5,\n      j = i;\n      smallestfind = 100;\n      findindex = 0;\n      loop( q31-j,\n            distance =megabuf(j*2+1);\n            smaller = above( smallestfind, distance);\n            smallestfind = if(smaller, distance, smallestfind);\n            findindex = if( smaller, j*2, findindex);\n            j = j + 1;\n          );\n\n      // now that the nearest object was found, swap it to the buffer's top\n\n      j = megabuf(i);\n      d = megabuf(i+1);\n\n      megabuf(i)   = megabuf(findindex);\n      megabuf(i+1) = megabuf(findindex+1);\n      megabuf(findindex)   = j;\n      megabuf(findindex+1) = d;\n\n      i = i+1;\n    );\n\n\nindex2 = (t1)%ppo;\ni = megabuf(index2-2);\nxx = 0.5 + (gmegabuf(i)-0.5)/q2;\nyy = 0.5 + (gmegabuf(i+1)-0.5)/q2;\nw = asin(1)*index2/4;\n//xx = x + sin(w)*0.1;\n//yy = y + cos(w)*0.1;\nx = if( equal(index2%2,0), x, xx);\ny = if( equal(index2%2,0), y, yy);\n\n\na = below(index2,ppo-1)*above(index2,1)*a;\nr = 0.5 + gmegabuf(index + 5)*0.5;\ng = 0.5 + gmegabuf(index + 6)*0.5;\nb = 0.5 + gmegabuf(index + 7)*0.5;\n\n\nt2 = t2 + equal(t1%ppo,ppo-1);\nt1 = t1 + 1;\n\n//a = above(t1,128);"},{"baseVals":{"samples":15,"thick":1,"additive":1,"scaling":5.92556,"smoothing":0,"a":0.4,"enabled":0},"init_eqs_eel":"t2 = 0","frame_eqs_eel":"t1 = 0;\nt2 = 0;\nt3 = 0;\nt4 = 0.5;","point_eqs_eel":"ppo = 5;\n\nindex = t2*q32;\nneighbor = 1;\nneighbor = gmegabuf(index+10+neighbor);\nx = 0.5 + (gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\nxx = 0.5 + ( gmegabuf(neighbor) - 0.5)/q2;\nyy = 0.5 + ( gmegabuf(neighbor+1) - 0.5)/q2;\n\nx = if( equal(t1 % 2, 0), x, xx);\ny = if( equal(t1 % 2, 0), y, yx);\n\n\nt2 = t2 + equal(t1,ppo);\nt1 = if(above(t1,ppo),t1-ppo,t1) + 1;\n"}],"init_eqs_eel":"// clear buffer\ni = 0; loop(1024*1024, gmegabuf(i) = 0; i = i+1;);\n\ncount = 50;\nattributes = 32;\nnListStart = 24; // starting index of neighbor list\n\nminradius = 0.004;\nmaxradius = 0.04;\nv = 0.0;\n\n// randomize initial coordinates\nindex = 0;\nloop(count,\n     gmegabuf(index*attributes) = rand(1000)/1000;\n     gmegabuf(index*attributes+1) = rand(1000)/1000;\n     gmegabuf(index*attributes+2) = v*(rand(1000)/1000-0.5);\n     gmegabuf(index*attributes+3) = v*(rand(1000)/1000-0.5);\n     gmegabuf(index*attributes+4) = minradius + (maxradius-minradius)*(index+1)/count;\n     gmegabuf(index*attributes+5) = 0;\n     gmegabuf(index*attributes+6) = 1;\n     gmegabuf(index*attributes+7) = 1;\n     gmegabuf(index*attributes+8) = pow(gmegabuf(index*attributes+4),3) ;\n     gmegabuf(index*attributes+9) = 4*asin(1)*rand(1000)/1000;\n     gmegabuf(index*attributes+10) = 0;\n     gmegabuf(index*attributes+13) = index/(count-1);\n     gmegabuf(index*attributes+14) = 0;\n     index = index+1;\n    );\n\nq30 = nListStart;\nq31 = count;\nq32 = attributes;\n\n// 0, x\n// 1, y\n// 2, vx\n// 3, vy\n// 4, radius\n// 5, red\n// 6, green\n// 7, blue\n// 8, mass\n// 9, angle\n// 10, rotation\n// 11, bend force\n// 12, bending\n// 13, sample\n// 14, spectrum","frame_eqs_eel":"dt = 1/fps;\n\nwarp = 0;\nzoom = 1;\nwave_a = 0;\n\ngravity = 0.0015*dt*0;\ndampening = 0;\nfriction = 2048*dt;\nshock = 0.002;\npi2 = asin(1);\n\nnn = 3; // number of nearest neighbors to search, reduce if not needed\n        // provide enough attributes, otherwise the next object's coordinate will be overwritten\n        // collision detection is based on nearest neighbors, so keep it at least at 1.\n\ncheck = 2; // how many neighbors will be checked for a possible collision. may not be above nn.\n           // raise to avoid odd behavior in clusters of touching objects.\n\nbouncefactor = 0.1;\nrotatefactor = 0; // relation between angular and translative momentum, when object hits a border. this is an empirical value for a convincing impression\n\n\n\nh = (aspecty-1)*0.5; w = (aspectx-1)*0.5;\nindex = 0; index2 = 0;\nloop(count,\n\n     random = rand(1000)/1000;\n     sample = gmegabuf(index+13);\n\n     // bend force\n     gmegabuf(index + 11) = gmegabuf(index + 11)*0.92 - 4*gmegabuf(index+12)*dt + 2*(random-0.5)*dt*gmegabuf(index+14);\n\n     // bend\n     gmegabuf(index + 12) += 60*gmegabuf(index + 11)*dt;\n\n     v = sqrt( sqr( gmegabuf(index + 2) ) + sqr( gmegabuf(index + 3) ) );\n\n     // apply friction\n     fric = max(0,1 - sqr(v*friction) - v*2);\n     gmegabuf(index + 2) *= fric;\n     gmegabuf(index + 3) *= fric;\n\n     // apply direction change\n     gmegabuf(index + 10) = gmegabuf(index + 10)*fric +  v*gmegabuf(index +12)*0;\n\n     // apply acceleration force\n     acceleration = random*0.000 + abs(gmegabuf(index+11))*0.003;\n     direction = gmegabuf(index + 9) - pi2;\n     gmegabuf(index + 2) += sin(direction)*acceleration;\n     gmegabuf(index + 3) += cos(direction)*acceleration;\n\n     // adding velocity vectors\n     gmegabuf(index) = gmegabuf(index) + gmegabuf(index+2)*60*dt;\n     gmegabuf(index+1) = gmegabuf(index+1) + gmegabuf(index+3)*60*dt;\n     gmegabuf(index+9) = gmegabuf(index+9) + gmegabuf(index+10)*0.5;\n\n     // applying gravity\n     gmegabuf(index+3) = gmegabuf(index+3) - gravity;\n\n     vr = sin(gmegabuf(index+10))*gmegabuf(index+4); // rotation speed at the surface\n\n     // bounce off ceiling\n     bounce = above( gmegabuf(index+1), 1 - gmegabuf(index+4) + w);\n     gmegabuf(index+2) = if( bounce, gmegabuf(index+2) + (vr+gmegabuf(index+2))*rotatefactor, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, -abs(gmegabuf(index+3))*dampening - shock, gmegabuf(index+3));\n     vr = if( bounce, vr - (gmegabuf(index+2) + vr)*(1-rotatefactor), vr);\n\n     // bounce off floor\n     bounce = below( gmegabuf(index+1), gmegabuf(index+4) - w);\n     gmegabuf(index+2) = if( bounce, gmegabuf(index+2) + (vr-gmegabuf(index+2))*rotatefactor, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, abs(gmegabuf(index+3))*dampening + shock, gmegabuf(index+3));\n     vr = if( bounce, vr + (gmegabuf(index+2) - vr)*(1-rotatefactor), vr);\n\n     // bounce off right border\n     bounce = above( gmegabuf(index), 1 - gmegabuf(index+4) + h);\n     gmegabuf(index+2) = if( bounce, -abs(gmegabuf(index+2))*dampening - shock, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, gmegabuf(index+3) + (vr-gmegabuf(index+3))*rotatefactor, gmegabuf(index+3));\n     vr = if( bounce, vr + (gmegabuf(index+3) - vr)*(1-rotatefactor), vr);\n\n     // bounce off left border\n     bounce = below( gmegabuf(index), gmegabuf(index+4) - h);\n     gmegabuf(index+2) = if( bounce, abs(gmegabuf(index+2))*dampening + shock, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, gmegabuf(index+3) - (vr+gmegabuf(index+3))*rotatefactor, gmegabuf(index+3));\n     vr = if( bounce, vr - (gmegabuf(index+3) + vr)*(1-rotatefactor), vr);\n\n     gmegabuf(index+10) = asin(vr/gmegabuf(index+4));\n\n     i = 0; j = 0; // collecting pairs of index and distance to the current object in a local buffer\n     loop( count,\n           d = sqrt( sqr(gmegabuf(index)-gmegabuf(i)) + sqr(gmegabuf(index+1)-gmegabuf(i+1)));\n           d = if( equal(d,0), 10, d); // leave out comparison with itself (where d == 0, set d to a high value)\n           d = d - (gmegabuf(index+4)+gmegabuf(i+4))*0.5; // subtract radius (surface to surface distance)\n           megabuf(j)   = i; // store index/distance pairs\n           megabuf(j+1) = d;\n           j = j+2;\n           i = i+attributes; );\n     i = 0; // sort that buffer, but only as many cycles as needed for the _nn_ nearest neighbors\n     loop( nn,\n           j = i; smallestfind = 10; findindex = -1;\n           loop( count-j,\n                 distance =megabuf(j*2+1);\n                 smaller = above( smallestfind, distance);\n                 smallestfind = if(smaller, distance, smallestfind);\n                 findindex = if( smaller, j*2, findindex);\n                 j = j + 1; );\n           j = megabuf(i*2); d = megabuf(i*2+1);\n           megabuf(i*2)   = megabuf(findindex);\n           megabuf(i*2+1) = megabuf(findindex+1);\n           megabuf(findindex)   = j;\n           megabuf(findindex+1) = d;\n           i = i+1;\n         );\n     i = 0; // storing the indexes of the nearest neighbors in the list\n     loop( nn,\n           gmegabuf(index + nListStart + i) = megabuf(i*2);\n           i = i +1;\n         );\n     i = 0; // collision detection and impulse transmission below\n     loop( check,\n           index2 = megabuf(i);\n           hit = below( sqrt( sqr( gmegabuf(index) - gmegabuf(index2)) +\n                              sqr( gmegabuf(index+1) - gmegabuf(index2+1))),\n                        gmegabuf(index + 4) + gmegabuf(index2 + 4)\n                      )\n                 *\n                 above( sqrt( sqr( gmegabuf(index)   - gmegabuf(index2))+\n                        sqr( gmegabuf(index+1) - gmegabuf(index2+1))),\n                        sqrt( sqr( gmegabuf(index+0) - gmegabuf(index2+0)+\n                                   gmegabuf(index+2) - gmegabuf(index2+2))+\n                              sqr( gmegabuf(index+1) - gmegabuf(index2+1)+\n                                   gmegabuf(index+3) - gmegabuf(index2+3)) ) );\n           ref_ang = atan2( gmegabuf(index2)-gmegabuf(index), // calculating the angle of the common tangent\n                            gmegabuf(index2 + 1)-gmegabuf(index + 1)) + pi2;\n           v1 = sqrt(sqr( gmegabuf(index + 2)) + sqr( gmegabuf(index + 3))); // velocity of object1\n           v2 = sqrt(sqr( gmegabuf(index2 + 2)) + sqr( gmegabuf(index2 + 3)));  // velocity of object2\n           w1 = atan2( gmegabuf(index + 2), gmegabuf(index + 3));   // object1 motion angle\n           w2 = atan2( gmegabuf(index2 + 2), gmegabuf(index2 + 3)); // object2 motion angle\n           vr2 = sin(gmegabuf(index2 + 10))*gmegabuf(index2+4); // the other object's surface velocity\n           m1 = gmegabuf(index + 8); m2 = gmegabuf(index2 + 8);\n           vv1 = ((m1-m2)*v1 + 2*m2*v2)/(m1+m2); vv2 = ((m2-m1)*v2 + 2*m1*v1)/(m1+m2);\n           vrr = ((m1-m2)*vr + 2*m2*vr2)/(m1+m2); vrr2 = ((m2-m1)*vr2 + 2*m1*vr)/(m1+m2);\n\n           gmegabuf( index + 2) = if( hit, sin(ref_ang)*v1*cos(w1-ref_ang) + ((vr-vr2)-sin(ref_ang)*v1*cos(w1-ref_ang))*0.1\n                                         + cos(ref_ang)*vv1*sin(w2-ref_ang),\n                                                  gmegabuf( index + 2) );\n\n           gmegabuf( index + 3) = if( hit, cos(ref_ang)*v1*cos(w1-ref_ang) + ((vr-vr2)-cos(ref_ang)*v1*cos(w1-ref_ang))*0.1\n                                         - sin(ref_ang)*vv1*sin(w2-ref_ang),\n                                                 gmegabuf( index + 3) );\n\n           gmegabuf( index2 + 2) = if( hit, sin(ref_ang)*v2*cos(w2-ref_ang) + ((vr2-vr)-sin(ref_ang)*v2*cos(w2-ref_ang))*0.1\n                                          + cos(ref_ang)*vv2*sin(w1-ref_ang),\n                                                  gmegabuf( index2 + 2) );\n\n           gmegabuf( index2 + 3) = if( hit, cos(ref_ang)*v2*cos(w2-ref_ang) + ((vr2-vr)-cos(ref_ang)*v2*cos(w2-ref_ang))*0.1\n                                          - sin(ref_ang)*vv2*sin(w1-ref_ang),\n                                                  gmegabuf( index2 + 3) );\n\n           vr = if( hit, vr + (cos(w1-ref_ang)*(v1-v2)-vr) , vr);\n           gmegabuf( index + 10) = asin( vr / gmegabuf(index+4) );\n\n           vr2 = if( hit, vr2 + (cos(w2-ref_ang)*(v2-v1)-vr2) , vr2);\n           gmegabuf( index2 + 10) = asin( vr2 / gmegabuf(index2+4) );\n\n           i=i+2;\n         );\n     index = index+attributes;\n    );\n\n\nq1 = aspectx;\nq2 = aspecty;","pixel_eqs_eel":"","warp":" shader_body { \n  vec3 ret_1;\n  ret_1.z = (texture (sampler_main, uv).z * 0.5);\n  vec2 tmpvar_2;\n  tmpvar_2 = ((uv_orig * texsize.xy) * texsize_noise_lq.zw);\n  vec2 tmpvar_3;\n  tmpvar_3 = (texsize.zw * 4.0);\n  vec2 tmpvar_4;\n  tmpvar_4.x = (((2.0 * \n    ((texture (sampler_blur1, (uv_orig + (vec2(1.0, 0.0) * tmpvar_3))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_orig - (vec2(1.0, 0.0) * tmpvar_3))).xyz * scale1) + bias1)\n  )).y * 0.5);\n  tmpvar_4.y = (((2.0 * \n    ((texture (sampler_blur1, (uv_orig + (vec2(0.0, 1.0) * tmpvar_3))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_orig - (vec2(0.0, 1.0) * tmpvar_3))).xyz * scale1) + bias1)\n  )).y * 0.5);\n  ret_1.y = texture (sampler_fw_main, clamp ((uv_orig + (\n    (tmpvar_4 * texsize.zw)\n   * 4.0)), 0.0, 1.0)).y;\n  ret_1.y = (ret_1.y + ((\n    (ret_1 - ((texture (sampler_blur1, uv_orig).xyz * scale1) + bias1))\n  .y * 0.025) + -0.014));\n  ret_1.y = (ret_1.y + ((texture (sampler_noise_lq, tmpvar_2).y - 0.5) * 0.02));\n  vec2 tmpvar_5;\n  tmpvar_5.x = (((2.0 * \n    ((texture (sampler_blur1, (uv_orig + (vec2(1.0, 0.0) * tmpvar_3))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_orig - (vec2(1.0, 0.0) * tmpvar_3))).xyz * scale1) + bias1)\n  )).x * 0.5);\n  tmpvar_5.y = (((2.0 * \n    ((texture (sampler_blur1, (uv_orig + (vec2(0.0, 1.0) * tmpvar_3))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_orig - (vec2(0.0, 1.0) * tmpvar_3))).xyz * scale1) + bias1)\n  )).x * 0.5);\n  ret_1.x = ((texture (sampler_main, (uv - \n    ((tmpvar_5 * texsize.zw) * 4.0)\n  )).x - (ret_1.y * 0.01)) + 0.004);\n  ret_1.x = (ret_1.x + ((\n    (texture (sampler_noise_lq, tmpvar_2).x - 0.5)\n   * 0.01) + (ret_1.z * 0.14)));\n  vec4 tmpvar_6;\n  tmpvar_6.w = 1.0;\n  tmpvar_6.xyz = ret_1;\n  ret = tmpvar_6.xyz;\n }","comp":" shader_body { \n  vec3 ret_1;\n  vec2 tmpvar_2;\n  tmpvar_2 = (texsize.zw * 4.0);\n  vec2 tmpvar_3;\n  tmpvar_3.x = (((2.0 * \n    ((texture (sampler_blur1, (uv + (vec2(1.0, 0.0) * tmpvar_2))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv - (vec2(1.0, 0.0) * tmpvar_2))).xyz * scale1) + bias1)\n  )) * 0.5).y;\n  tmpvar_3.y = (((2.0 * \n    ((texture (sampler_blur1, (uv + (vec2(0.0, 1.0) * tmpvar_2))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv - (vec2(0.0, 1.0) * tmpvar_2))).xyz * scale1) + bias1)\n  )) * 0.5).y;\n  vec2 tmpvar_4;\n  tmpvar_4 = (uv - ((tmpvar_3 * texsize.zw) * 128.0));\n  vec4 tmpvar_5;\n  tmpvar_5 = texture (sampler_main, uv);\n  ret_1 = (((\n    ((texture (sampler_blur2, tmpvar_4).xyz * scale2) + bias2)\n  .x * \n    clamp ((1.0 - tmpvar_5.y), 0.0, 1.0)\n  ) * pow (hue_shader.yxz, vec3(8.0, 8.0, 8.0))) * 3.0);\n  ret_1 = (mix (mix (ret_1, \n    (pow (hue_shader.yzx, vec3(8.0, 8.0, 8.0)) * 1.4)\n  , vec3(\n    ((texture (sampler_main, tmpvar_4).x * 0.8) + ((texture (sampler_blur1, tmpvar_4).xyz * scale1) + bias1).x)\n  )), vec3(1.0, 1.0, 1.0), (\n    (pow (hue_shader, vec3(8.0, 8.0, 8.0)) * texture (sampler_main, clamp (uv, 0.0, 1.0)).y)\n   * 1.2)) * clamp ((1.0 - tmpvar_5.z), 0.0, 1.0));\n  vec4 tmpvar_6;\n  tmpvar_6.w = 1.0;\n  tmpvar_6.xyz = ret_1;\n  ret = tmpvar_6.xyz;\n }"}