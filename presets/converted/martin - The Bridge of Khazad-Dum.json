{"version":2,"baseVals":{"rating":4,"gammaadj":1.98,"decay":0.5,"echo_zoom":0.952,"echo_alpha":0.5,"echo_orient":3,"wave_mode":4,"additivewave":1,"wave_thick":1,"modwavealphabyvolume":1,"wave_brighten":0,"darken":1,"wave_a":0.001,"wave_scale":0.527,"wave_smoothing":0.45,"modwavealphastart":0,"modwavealphaend":1.32,"warpanimspeed":1.459,"warpscale":2.007,"zoom":0.9999,"warp":0.01,"sx":0.9999,"wave_r":0.8,"wave_g":0.49,"ob_size":0.015,"ob_b":1,"ib_size":0.26,"mv_x":64,"mv_y":48,"mv_l":1.85,"mv_r":0.5,"mv_g":0.5,"mv_b":0.5,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{"sides":33,"additive":1,"num_inst":81,"rad":0.04896,"tex_ang":1.00531,"tex_zoom":1.53117,"g":1,"b":1,"a":0,"g2":0,"border_b":0,"border_a":0,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"\ntrel = time/8;\nk1 = instance/num_inst;\nk2 = k1 + trel - int(k1+trel);\n\ny0 = k2+.01 ;\n\nxwidth = .1*(cos(6*k1)+3); //breite\nxofs = .1*cos(k2*6+trel)*y0;\nx = .5 + .4*xwidth*(.2+y0)*sin(k1*1383*xwidth) + xofs;\n//xwidth in der letzten Klammer : Test\n\ny = y0;\n\nbright = 1-sqr(y0); \na = max(bright,0); a2 = 0;\nrad = .4*y0+.1 - .0*sin(k1*954);\n\nr = .0; g = 0; b = .0;\nr2 = 0; g2 = 0; b2= .48; //## rot mit ampl. mod !\nadditive = 1; ///sonst andere farben im warp-s gestoert"},{"baseVals":{"enabled":1,"sides":12,"additive":1,"num_inst":571,"x":0.26,"y":0.2,"rad":0.39317,"tex_zoom":0.9355,"g2":0,"a2":0.2,"border_g":0,"border_b":0,"border_a":0},"init_eqs_eel":"","frame_eqs_eel":"mov1 = q1;\nRotMode = q3;\nburst = q10;\ncopies = q14;\ncopy = (instance%copies)/copies;\nk1 = int(instance/copies)*copies/num_inst;\nk1 = int(k1*burst)/burst+k1/burst;\n\nmov1 = mov1 + k1 -copy*q2;//dt\nmov1 = mov1 - int(mov1);\n\nRotMode = RotMode - copy*q4;\nrota = mov1 * RotMode*q5*2 ;\nmov1 = mov1*(1-RotMode) + RotMode*(.5+.025*k1);\n\nmov1 = pow(mov1,.9); //Schneller bei t=0;\n\nTht = sin(k1*k1*123.2)*(.2 + RotMode*.0);\nPhi = k1*1613.3+rota;\nv0 = (1.0 + .3*cos(k1*13234.7))*q5;\n\nz0 = q18/q5; //proximity\n\nt0 = .4;\nspur = (mov1-t0) * above(mov1-t0,0)*q15 ;\npy = spur*sin(copy*6.28);\npx = spur*cos(copy*6.28);\n\nfov = z0*2; //kein vol hier, sonst y-skal daneben\nox = (mov1-q19)*v0*sin(Tht) * cos(Phi); //### -.5 bis .5\noy = mov1*v0*(1-mov1)*cos(2*Tht) -.25;\noz = mov1*v0*sin(Tht)*sin(Phi); \n\nox = ox +  (k1-.5)*q17 +px; \noy = oy -py;\noz = oz +py*3;\n\n//flim = below(((ox+oy+oz)*800)%32,q13-.1); //ctrl\n//flim = q13/(((ox+oy+oz)*600)%16+1); //ctrl\nrad = .025*z0/(oz+z0)*(1-mov1*.5);\n\nx = .5 + fov*ox/(oz+z0);\ny = .5 + fov*oy/(oz+z0);\nvis = above(mov1,q11)*below(mov1,q12)*above(oz,-z0);\n\na = vis*.7/sqrt(copies)*(1+above(spur,0));\na2 = 0.;\ng = flim;"},{"baseVals":{"enabled":1,"sides":13,"additive":1,"num_inst":212,"x":0.65,"y":0.38,"rad":1.26467,"tex_zoom":0.73678,"g":1,"a":0.3,"r2":1,"g2":0,"border_r":0.5,"border_g":0.5,"border_b":0,"border_a":0},"init_eqs_eel":"","frame_eqs_eel":"//q25 = time/4;\n//trel = 2* (q25/2-int(q25/2));\ntrel = q25;\ncopies = 1;\ncopy = (instance%copies)/copies;\nk1 = int(instance/copies)*copies/num_inst;\nk2 = k1 + .5;\ntrel = trel ;\nt0 = .5; //do not change\n\nphase = above(trel,t0);\nmov1 = bnot(phase)* (t0-trel + .01*k1);\nmov2 = phase * (trel-t0); //####\n//mov2 = pow(mov2,.8);\nstray = 1.2-phase;\n\nTht = 3.14*sin(1234.2*k1+time*bnot(phase)) * stray ;\nPhi = 3245.1*k1;\n\nsize0 = .02;\nox = mov1*q27 + sin(Tht)*cos(phi)* (size0+mov2*(2+k1));\noy = mov1*12 + cos(Tht)* (size0+4*mov2*k2)*(1-mov2*k2)/2;\noz = mov1*8 + sin(Tht)*sin(phi)* (size0+mov2*2*(2+k1));\n\nz0 = 1;\nrad = .03 / (oz+z0)/(1+trel*rand(100)/50);\n\nx = .5 + ox/(oz+z0);\ny = q29+.2+ oy/(oz+z0);\n\na = .1*bnot(phase)+phase*max(0,1-mov2*0)*above(oz+z0,0)*.8; "},{"baseVals":{"sides":14,"additive":1,"thickoutline":1,"textured":1,"num_inst":31,"x":0.75,"y":0.6,"rad":0.01,"tex_zoom":0.3357,"g":1,"a":0.5,"r2":1,"g2":0,"border_r":0.2,"border_g":0.7,"border_b":0.5,"border_a":0,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"samples":75,"sep":20,"usedots":1,"additive":1,"scaling":7.858,"smoothing":0.1,"g":0,"b":0,"a":0.2,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"usedots":1,"thick":1,"scaling":0.89152,"smoothing":0.82,"a":0.1,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"thick":1,"scaling":0.89152,"smoothing":0.82,"r":0,"g":0.2,"b":0,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"spectrum":1,"usedots":1,"enabled":0},"init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_eel":"t0a = time; t0 = time+.5;\nspb_ = .5; ;\nvolb = .5; volx = .5;\nvol_= 1; index = 0; mov1 = 0;","frame_eqs_eel":"dec_med = pow (0.85, 30/fps); dec_slow = pow (0.95, 30/fps);\nvol = (bass+med+treb)/1.5; vol_ = vol_*dec_slow + (1-dec_slow)*vol;\n\nis_beat = above(vol, .1+vol_+2*peak) * above (time, t0+spb_*.45);\nt0a  = if(is_beat,t0,t0a); t0 = if(is_beat,time,t0);\npeak = if(is_beat,vol,peak*dec_med);\nindex = (index + is_beat) %128;\nspb_ = if(is_beat,spb_ *.9 +.1*min(t0-t0a + .01,2), spb_);\n\nq20 = vol_;\nq21 = above(vol,2.7*vol_);\nq22 = max(0,peak-.0)+.01;\nhpeak = hpeak*dec_med + (1-dec_med)*q21;\nq23 = hpeak * (1+rand(8));\nq24 = is_beat;\nvolb = bnot(q24)*volb + q24*vol_; //# vol oder vol_ ?\nvolx = volx + .2/fps*max(min(volb-volx,1),-1)*bnot(RotMode);\n\n// *********** CENTRAL TIMELINE **************\nrotmode = max(min(sin(mov1/2.4-1.5)*4-3,1),0); //####\nstop = if(bnot(stop),bnot(index%24),below(lo,1))*bnot(rotmode);\n//tmp = status%16;\nspread = if (below(lo,1),spread,rand(2)*rand(12)/20);\ncopies = if (below(lo,1),copies,3+rand(2)*rand(8));\nspur  = if (below(lo,1),spur, above(copies,5)*.1);\nbursts = if (below(lo,1),bursts,1+rand(2)*rand(6));\nxbase = if (below(lo,1),xbase,rand(2)*(rand(10)/10-.5));\nvs0 = if (is_beat * bnot(index%77),rand(5)/4-.7,vs0);\nvshift =  vshift + 3/fps*max(min((vs0-vshift),.04),-.04);\n//*********** SMOOTH MOVEMENTS q1 - q8 for SHAPE2 ********\n//FONTAENE\nspeed = .15/fps/spb_;\ntmp = mov1; mov1 = mov1+speed; q2 = mov1-tmp; q1 = mov1;\n\n//ROTATION\n//evtl q5 mit rotmode fixieren statt volx blockieren\ntmp = RotMode; q3 = RotMode; q4 = RotMode-tmp;\n\n//VOLUME\ntmp = volx; q5 = volx; q6 = q5-tmp; //nicht aendern waehrend Rotation\n\n//********* SWITCHES SHAPE2 *************\nq10 = bursts; //num bursts\nlo = if(stop,lo+speed,0); //ident. wie bei mov 1!!\nhi = if(above(lo,1),0,hi+speed); //ident. wie bei mov 1!!\nq11 = lo; //fade out\nq12 = hi;\nq13 = sqrt(q22)*0; //blink effect, ca. 0..16\nq14 = copies; //copies - noch implementieren\nq15 = spur*(1-RotMode); //Ampl. multiple spurs; nur mit >8 copies !\nq16 = 0; //reserved for spur start\nq17 = spread * (1-rotmode); //hor. spread, max. ca. 0.4\nq18 = 1/min(max(sin(mov1/2)*10,1),4); //proximity - smaller values: closer;\nq19 = xbase;\n//********* CONTROL PARAMETERS SHAPE3 *************\nxtime = if (stop*q21*above(xtime,2),0,xtime+.2/fps); //impact\nq25 = xtime;\nq26 = if (below(xtime,.55),pow(32,-sqr(xtime-.55)*512),pow(2,-sqr(xtime-.55)*3));\nq27 = sin(time/29)*4; //x-direction impact\n\n//********* GENERAL CONTROL PARAMETERS ***************\nwind = wind+.5/fps * (volx-1.5);\nq28 = wind;//wind direction - warp shader\nq29 = vshift ;// in warp+comp+impact shape\nq30 = max(sin(mov1/2.2)*sin(time/7),0)+q26;// front cloud dens. - comp.\nq31 = q5*2-2 + sin(time/17); //back cloud lighting - comp shader\nq32 = 3+2*sin(time/27); //back cloud density - comp shader\n\nmonitor = vshift;;","pixel_eqs_eel":"zoom = 1;\ndy = -.00;\nwarp =.0;","warp":"mat2 ofs;\nfloat xlat_mutablegreen;\nfloat xlat_mutablek1;\nfloat xlat_mutablered;\nvec2 xlat_mutableuv2;\nfloat xlat_mutablewave;\nfloat xlat_mutablezv;\n shader_body { \n  mat2 tmpvar_1;\n  tmpvar_1[uint(0)].x = texsize.z;\n  tmpvar_1[uint(0)].y = 0.0;\n  tmpvar_1[1u].x = 0.0;\n  tmpvar_1[1u].y = texsize.w;\n  ofs = (tmpvar_1 * 4.0);\n  float delta_2;\n  float ky_3;\n  vec2 tmpvar_4;\n  tmpvar_4.x = (uv.x - 0.5);\n  tmpvar_4.y = ((uv.y - 0.5) + q29);\n  vec2 v_5;\n  v_5.x = ofs[0].x;\n  v_5.y = ofs[1].x;\n  vec2 v_6;\n  v_6.x = ofs[0].x;\n  v_6.y = ofs[1].x;\n  vec2 v_7;\n  v_7.x = ofs[0].y;\n  v_7.y = ofs[1].y;\n  vec2 v_8;\n  v_8.x = ofs[0].y;\n  v_8.y = ofs[1].y;\n  vec2 tmpvar_9;\n  tmpvar_9.x = (texture (sampler_main, (uv + v_5)) - texture (sampler_main, (uv - v_6))).x;\n  tmpvar_9.y = (texture (sampler_main, (uv + v_7)) - texture (sampler_main, (uv - v_8))).x;\n  xlat_mutablered = (0.5 * texture (sampler_main, (uv - (0.004 * tmpvar_9))).x);\n  xlat_mutablered = (xlat_mutablered + (0.5 * texture (sampler_main, uv).x));\n  vec2 tmpvar_10;\n  tmpvar_10.x = tmpvar_4.x;\n  tmpvar_10.y = (0.0078125 * (float(\n    int((tmpvar_4.y * 128.0))\n  ) + abs(\n    (fract((tmpvar_4.y * 128.0)) - 0.5)\n  )));\n  vec2 tmpvar_11;\n  tmpvar_11 = (tmpvar_10 * 4.0);\n  ky_3 = clamp ((-0.5 - tmpvar_11.y), 0.0, 1.0);\n  xlat_mutablek1 = (abs((\n    fract((tmpvar_11.x * 2.0))\n   - 0.5)) * 8.0);\n  xlat_mutablek1 = (xlat_mutablek1 - sign(xlat_mutablek1));\n  delta_2 = (0.1 + (rand_preset * 0.05)).x;\n  xlat_mutablek1 = (xlat_mutablek1 - ((\n    (4.0 * sign(xlat_mutablek1))\n   * ky_3) * ky_3));\n  ky_3 = clamp ((ky_3 - delta_2), 0.0, 1.0);\n  xlat_mutablek1 = (xlat_mutablek1 - ((\n    (8.0 * sign(xlat_mutablek1))\n   * ky_3) * ky_3));\n  ky_3 = clamp ((ky_3 - delta_2), 0.0, 1.0);\n  xlat_mutablek1 = (xlat_mutablek1 - ((\n    (12.0 * sign(xlat_mutablek1))\n   * ky_3) * ky_3));\n  ky_3 = clamp ((ky_3 - delta_2), 0.0, 1.0);\n  xlat_mutablek1 = (xlat_mutablek1 - ((\n    (16.0 * sign(xlat_mutablek1))\n   * ky_3) * ky_3));\n  ky_3 = clamp ((ky_3 - delta_2), 0.0, 1.0);\n  float tmpvar_12;\n  tmpvar_12 = clamp (xlat_mutablek1, -1.6, 1.6);\n  xlat_mutablek1 = tmpvar_12;\n  xlat_mutablegreen = (cos((tmpvar_12 * 2.0)) - 0.1);\n  xlat_mutablewave = ((sin(\n    ((q1 * 8.0) - (uv.x * 6.0))\n  ) / 2.0) * q3);\n  xlat_mutablewave = ((xlat_mutablewave * float(\n    (xlat_mutablewave >= 0.0)\n  )) + (q30 * 0.02));\n  xlat_mutablered = (xlat_mutablered + ((\n    (xlat_mutablewave / abs(sin((\n      (1.0/(tmpvar_12))\n     + \n      (q1 / 8.0)\n    ))))\n   * xlat_mutablegreen) * ky_3));\n  xlat_mutablezv = ((time * 0.08) + (0.2 * sin(\n    ((uv * 16.0) + time)\n  ))).x;\n  vec2 tmpvar_13;\n  tmpvar_13.x = q28;\n  tmpvar_13.y = (0.2 * time);\n  xlat_mutableuv2 = ((tmpvar_4 * 2.0) + tmpvar_13);\n  vec3 tmpvar_14;\n  tmpvar_14.xy = xlat_mutableuv2;\n  tmpvar_14.z = xlat_mutablezv;\n  vec3 tmpvar_15;\n  tmpvar_15.xy = (xlat_mutableuv2 * vec2(2.0, 2.0));\n  tmpvar_15.z = (xlat_mutablezv * 2.0);\n  vec3 tmpvar_16;\n  tmpvar_16.xy = (xlat_mutableuv2 * vec2(4.0, 4.0));\n  tmpvar_16.z = (xlat_mutablezv * 3.0);\n  vec3 tmpvar_17;\n  tmpvar_17.xy = (xlat_mutableuv2 * vec2(8.0, 8.0));\n  tmpvar_17.z = (xlat_mutablezv * 7.0);\n  xlat_mutableuv2 = (tmpvar_4 + ((\n    ((texture (sampler_noisevol_hq, tmpvar_14).z + (texture (sampler_noisevol_hq, tmpvar_15).z / 2.0)) + (texture (sampler_noisevol_hq, tmpvar_16).z / 4.0))\n   + \n    (texture (sampler_noisevol_hq, tmpvar_17).z / 8.0)\n  ) * 0.1));\n  vec3 tmpvar_18;\n  tmpvar_18.x = xlat_mutablered;\n  tmpvar_18.y = xlat_mutablegreen;\n  tmpvar_18.z = ((1.0 + xlat_mutableuv2.y) * sqrt(dot (xlat_mutableuv2, xlat_mutableuv2)));\n  vec4 tmpvar_19;\n  tmpvar_19.w = 1.0;\n  tmpvar_19.xyz = ((tmpvar_18 * 0.8) - 0.005);\n  ret = tmpvar_19.xyz;\n }","comp":"float trel;\nfloat vshift;\nvec3 xlat_mutableret1;\nvec2 xlat_mutablers;\nvec2 xlat_mutablers0;\nfloat xlat_mutablesmoke;\nfloat xlat_mutablesmoke2;\nvec2 xlat_mutableuv_l;\nfloat xlat_mutablew;\nfloat xlat_mutablez;\n shader_body { \n  trel = (time / 2.0);\n  vshift = (0.5 - q29);\n  vec2 tmpvar_1;\n  tmpvar_1.x = rand_preset.x;\n  tmpvar_1.y = ((-0.1 - (rand_preset.y / 2.0)) + vshift);\n  vec2 tmpvar_2;\n  tmpvar_2.y = 0.0;\n  tmpvar_2.x = (0.005 * time);\n  xlat_mutableuv_l = (uv + tmpvar_2);\n  vec2 tmpvar_3;\n  vec2 tmpvar_4;\n  tmpvar_4 = (uv - 0.5);\n  tmpvar_3 = sin(((\n    (tmpvar_4 * aspect.xy)\n   + 0.5) - (tmpvar_1 * aspect.xy)));\n  vec2 tmpvar_5;\n  tmpvar_5 = fract(uv);\n  vec3 tmpvar_6;\n  tmpvar_6 = vec3((texture (sampler_fc_main, tmpvar_5).x + (2.0 * (\n    (texture (sampler_blur2, tmpvar_5).xyz * scale2)\n   + bias2).x)));\n  vec3 tmpvar_7;\n  tmpvar_7.x = tmpvar_6.x;\n  tmpvar_7.y = pow (tmpvar_6.x, 2.1);\n  tmpvar_7.z = pow (tmpvar_6.x, 4.0);\n  xlat_mutablew = ((uv.y - (\n    ((dot (texture (sampler_noise_hq, vec2((xlat_mutableuv_l.x / 6.0))), vec4(0.32, 0.49, 0.29, 0.0)) + uv.x) - 0.5)\n   / 4.0)) - vshift);\n  xlat_mutablez = (0.2 / xlat_mutablew);\n  float tmpvar_8;\n  tmpvar_8 = clamp ((-0.2 - (\n    (8.0 * q5)\n   * xlat_mutablew)), 0.0, 1.0);\n  xlat_mutablers0.x = (((uv.x - 0.5) * (1.0 + \n    abs(xlat_mutablez)\n  )) * 2.0);\n  xlat_mutablers0.y = xlat_mutablez;\n  xlat_mutablers0 = (xlat_mutablers0 * ((4.0 * \n    float((xlat_mutablez <= 0.0))\n  ) + 1.0));\n  vec2 tmpvar_9;\n  tmpvar_9.x = 0.0;\n  tmpvar_9.y = (1.5 + xlat_mutablew);\n  vec2 x_10;\n  x_10 = (xlat_mutablers0 - tmpvar_9);\n  float tmpvar_11;\n  tmpvar_11 = ((q26 / sqrt(\n    dot (x_10, x_10)\n  )) / 4.0);\n  xlat_mutablers0 = (xlat_mutablers0 * (1.0 + (tmpvar_11 * tmpvar_11)));\n  xlat_mutablers.x = (xlat_mutablers0 * 2.0).x;\n  xlat_mutablers.y = (xlat_mutablers0.y + (trel * 0.5));\n  float tmpvar_12;\n  tmpvar_12 = (texture (sampler_main, uv).y * tmpvar_8);\n  vec3 tmpvar_13;\n  tmpvar_13.xy = (xlat_mutablers * 2.0);\n  tmpvar_13.z = (0.2 * trel);\n  float tmpvar_14;\n  tmpvar_14 = dot (((\n    ((2.0 * clamp ((texture (sampler_noisevol_hq, \n      (tmpvar_13 * float((xlat_mutablez >= 0.0)))\n    ) - 0.2), 0.0, 1.0)).xyz * clamp ((texture (sampler_noise_hq, (xlat_mutablers / 16.0)) - 0.5), 0.0, 1.0).x)\n   / \n    sqrt(abs(xlat_mutablez))\n  ) + tmpvar_11), vec3(0.32, 0.49, 0.29));\n  vec3 tmpvar_15;\n  tmpvar_15.x = tmpvar_14;\n  tmpvar_15.y = pow (tmpvar_14, 2.1);\n  tmpvar_15.z = pow (tmpvar_14, 6.0);\n  xlat_mutableret1 = (((\n    ((uv.y * (1.0 + q23)) + (0.1 / sqrt(dot (tmpvar_3, tmpvar_3))))\n   * vec3(0.1, 0.1, 0.2)) * tmpvar_8) + (clamp (tmpvar_15, 0.0, 1.0) * (1.0 - \n    clamp ((-1.0 - (12.0 * xlat_mutablew)), 0.0, 1.0)\n  )));\n  xlat_mutableret1 = (xlat_mutableret1 * clamp ((1.0 - \n    (tmpvar_12 * 8.0)\n  ), 0.0, 1.0));\n  vec4 tmpvar_16;\n  tmpvar_16 = texture (sampler_main, fract((tmpvar_4 + 0.5)));\n  xlat_mutablesmoke = (tmpvar_16.z * (tmpvar_16.z * q5));\n  xlat_mutableret1 = (xlat_mutableret1 * clamp ((1.0 - \n    ((xlat_mutablesmoke * q32) * tmpvar_8)\n  ), 0.0, 1.0));\n  xlat_mutablesmoke2 = (texture (sampler_main, ((tmpvar_4 / 2.0) + 0.5)).z * q30);\n  xlat_mutableret1 = (xlat_mutableret1 + (clamp (tmpvar_7, 0.0, 1.0) - (\n    ((xlat_mutablez * clamp ((xlat_mutablesmoke + \n      (xlat_mutablew * q31)\n    ), 0.0, 1.0)) * vec3(1.0, 0.4, 0.1))\n   * tmpvar_8)));\n  float tmpvar_17;\n  tmpvar_17 = clamp (((\n    (tmpvar_12 * xlat_mutablez)\n   * xlat_mutablez) / 16.0), 0.0, 1.0);\n  vec3 tmpvar_18;\n  tmpvar_18.x = tmpvar_17;\n  tmpvar_18.y = pow (tmpvar_17, 2.1);\n  tmpvar_18.z = pow (tmpvar_17, 6.0);\n  xlat_mutableret1 = (xlat_mutableret1 + clamp (tmpvar_18, 0.0, 1.0));\n  xlat_mutableret1 = (xlat_mutableret1 * clamp ((\n    (((dot (texture (sampler_noise_mq, vec2(\n      ((xlat_mutableuv_l.x / 4.0) + (0.02 * trel))\n    )), vec4(0.32, 0.49, 0.29, 0.0)) / 6.0) - uv.y) + 0.8)\n   * 32.0), 0.0, 1.0));\n  vec3 tmpvar_19;\n  tmpvar_19.x = xlat_mutablesmoke2;\n  tmpvar_19.y = pow (xlat_mutablesmoke2, 2.1);\n  tmpvar_19.z = pow (xlat_mutablesmoke2, 6.0);\n  xlat_mutableret1 = ((xlat_mutableret1 * clamp (\n    (1.0 - xlat_mutablesmoke2)\n  , 0.0, 1.0)) + clamp (tmpvar_19, 0.0, 1.0));\n  vec4 tmpvar_20;\n  tmpvar_20.w = 1.0;\n  tmpvar_20.xyz = (1.0 - exp((\n    -(xlat_mutableret1)\n   * 2.0)));\n  ret = tmpvar_20.xyz;\n }"}